// src/features/attributeMapping/components/organisms/CsfTree.jsx
import * as React from 'react';
import {
  Box, Paper, Stack, Typography, IconButton, Collapse, Divider, Chip,
  List, ListItemButton, ListItemText
} from '@mui/material';
import { ExpandMore, ExpandLess } from '@mui/icons-material';
import FunctionBadge from '../atoms/FunctionBadge';

/* function color swatch (same palette weâ€™ve been using) */
const funcColor = (name='') => {
  if (name.includes('(GV)')) return '#f9f49d';
  if (name.includes('(ID)')) return '#4bb2e0';
  if (name.includes('(PR)')) return '#918cea';
  if (name.includes('(DE)')) return '#fab746';
  if (name.includes('(RS)')) return '#e57676';
  if (name.includes('(RC)')) return '#7df59f';
  return '#cfd8dc';
};

/**
 * Left navigation tree for CSF 2.0
 * - Browse mode (selectedSubcatID == null): show rich headers with languages
 * - Compact mode   (selectedSubcatID != null): focus on the selected subcat; Function/Category compact (names only),
 *   Subcategory shows name + language. Only the owning Function & Category are opened.
 */
export default function CsfTree({
  headers = [],
  onSelectSubcat,
  selectedSubcatID = null,
  maxHeight = 'calc(100vh - 200px)',
}) {
  const compactMode = !!selectedSubcatID; // collapse view when a subcat has been chosen

  /* -------- aggregate counts per subcategory -------- */
  const countsBySub = React.useMemo(() => {
    const m = new Map();
    headers.forEach(h => {
      const id = h.csF2SubcategoryID;
      const acc = m.get(id) || { kept:0, removed:0, custom:0 };
      acc.kept    += Number(h.keptCount    || 0);
      acc.removed += Number(h.removedCount || 0);
      acc.custom  += Number(h.customCount  || 0);
      m.set(id, acc);
    });
    return m;
  }, [headers]);

  /* -------- build Function -> Category -> Subcategory tree -------- */
  const tree = React.useMemo(() => {
    const fM = new Map();
    headers.forEach(h => {
      if (!fM.has(h.functionID)) {
        fM.set(h.functionID, {
          id: h.functionID, name: h.functionName, desc: h.functionLanguage || '', cats: new Map()
        });
      }
      const f = fM.get(h.functionID);

      if (!f.cats.has(h.categoryID)) {
        f.cats.set(h.categoryID, {
          id: h.categoryID, name: h.categoryName, desc: h.categoryLanguage || '', subs: new Map()
        });
      }
      const c = f.cats.get(h.categoryID);

      if (!c.subs.has(h.csF2SubcategoryID)) {
        c.subs.set(h.csF2SubcategoryID, {
          id: h.csF2SubcategoryID,
          name: h.csF2SubcategoryName,
          desc: h.csF2SubcategoryLanguage || '',
          counts: countsBySub.get(h.csF2SubcategoryID) || { kept:0, removed:0, custom:0 }
        });
      }
    });

    // flatten maps into arrays
    return Array.from(fM.values()).map(f => ({
      ...f,
      cats: Array.from(f.cats.values()).map(c => ({ ...c, subs: Array.from(c.subs.values()) }))
    }));
  }, [headers, countsBySub]);

  /* -------- locate the owning Function/Category for the selected subcat -------- */
  const ownerIds = React.useMemo(() => {
    if (!selectedSubcatID) return { funcId: null, catId: null };
    for (const f of tree) {
      for (const c of f.cats) {
        const has = c.subs.some(s => String(s.id) === String(selectedSubcatID));
        if (has) return { funcId: f.id, catId: c.id };
      }
    }
    return { funcId: null, catId: null };
  }, [tree, selectedSubcatID]);

  /* -------- expand/collapse state (multiple functions/categories can be open) -------- */
  const [openFuncs, setOpenFuncs] = React.useState(new Set());
  const [openCats, setOpenCats]   = React.useState(new Set());

  // When a subcat is selected, focus: open only its owner Function & Category.
  React.useEffect(() => {
    if (!compactMode || !ownerIds.funcId) return;
    setOpenFuncs(new Set([ownerIds.funcId]));
    setOpenCats(new Set([`${ownerIds.funcId}:${ownerIds.catId}`]));
  }, [compactMode, ownerIds.funcId, ownerIds.catId]);

  const toggleFunc = (fid) => {
    setOpenFuncs(prev => {
      const n = new Set(prev);
      if (n.has(fid)) n.delete(fid); else n.add(fid);
      return n;
    });
  };

  const toggleCat = (fid, cid) => {
    const key = `${fid}:${cid}`;
    setOpenCats(prev => {
      const n = new Set(prev);
      if (n.has(key)) n.delete(key); else n.add(key);
      return n;
    });
  };

  /* -------- render -------- */
  return (
    <Box sx={{ maxHeight, overflow: 'auto' }}>
      {tree.map((f) => {
        const fOpen = openFuncs.has(f.id);
        return (
          <Paper key={f.id} variant="outlined" sx={{ mb: 2, borderRadius: 2 }}>
            {/* Function header */}
            <Stack direction="row" alignItems="center" justifyContent="space-between" sx={{ p: 1.25 }}>
              <Stack direction="row" spacing={1.25} alignItems="center">
                <Box sx={{ width:10, height:10, borderRadius: '3px', bgcolor: funcColor(f.name) }} />
                <FunctionBadge functionName={f.name} />
                <Typography variant="subtitle1" fontWeight={700}>{f.name}</Typography>
              </Stack>
              <IconButton size="small" onClick={() => toggleFunc(f.id)}>
                {fOpen ? <ExpandLess/> : <ExpandMore/>}
              </IconButton>
            </Stack>

            <Collapse in={fOpen} unmountOnExit>
              {!compactMode && f.desc && (
                <Typography variant="caption" color="text.secondary" sx={{ px: 1.5, pb: 1 }}>
                  {f.desc}
                </Typography>
              )}
              <Divider />
              <Box sx={{ p: 1.25, pt: 1 }}>
                {f.cats.map((c) => {
                  const key = `${f.id}:${c.id}`;
                  const cOpen = openCats.has(key);
                  return (
                    <Paper key={c.id} variant="outlined" sx={{ mb: 1.25, borderRadius: 2, bgcolor: 'background.default' }}>
                      {/* Category header: always show name; show language only in browse mode */}
                      <Stack direction="row" alignItems="center" justifyContent="space-between" sx={{ p: 1 }}>
                        <Box>
                          <Typography variant="body1" fontWeight={700}>{c.name}</Typography>
                          {!compactMode && c.desc ? (
                            <Typography variant="caption" color="text.secondary">{c.desc}</Typography>
                          ) : null}
                        </Box>
                        <IconButton size="small" onClick={() => toggleCat(f.id, c.id)}>
                          {cOpen ? <ExpandLess/> : <ExpandMore/>}
                        </IconButton>
                      </Stack>

                      <Collapse in={cOpen} unmountOnExit>
                        <Divider />
                        <List dense disablePadding sx={{ py: .5 }}>
                          {c.subs.map(s => {
                            const selected = String(s.id) === String(selectedSubcatID);
                            return (
                              <ListItemButton
                                key={s.id}
                                onClick={() => onSelectSubcat?.(s.id)}
                                selected={selected}
                                sx={{ px: 1.25, py: .75, borderRadius: 1, mb: .25 }}
                              >
                                <ListItemText
                                  primary={
                                    <Stack direction="row" spacing={1} alignItems="center" useFlexGap flexWrap="wrap">
                                      <Typography variant="body2" fontWeight={700}>{s.name}</Typography>
                                      <Chip size="small" label={`${s.counts.kept} Kept`}    sx={{ bgcolor:'#e8f5e9', color:'#1b5e20' }}/>
                                      <Chip size="small" label={`${s.counts.removed} Removed`} sx={{ bgcolor:'#ffebee', color:'#b71c1c' }}/>
                                      <Chip size="small" label={`${s.counts.custom} Custom`}  sx={{ bgcolor:'#e3f2fd', color:'#0d47a1' }}/>
                                    </Stack>
                                  }
                                  // Always show subcategory language (both modes)
                                  secondary={s.desc}
                                  secondaryTypographyProps={{ variant:'caption', color:'text.secondary' }}
                                />
                              </ListItemButton>
                            );
                          })}
                        </List>
                      </Collapse>
                    </Paper>
                  );
                })}
              </Box>
            </Collapse>
          </Paper>
        );
      })}
    </Box>
  );
}
