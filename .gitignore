import * as React from 'react';
import {
  Box, Paper, Stack, Select, MenuItem, TextField, Button, Chip,
  IconButton, Tooltip, Divider, Typography
} from '@mui/material';
import EditOutlinedIcon from '@mui/icons-material/EditOutlined';
import DeleteOutlineOutlinedIcon from '@mui/icons-material/DeleteOutlineOutlined';
import SaveOutlinedIcon from '@mui/icons-material/SaveOutlined';
import CloseOutlinedIcon from '@mui/icons-material/CloseOutlined';
import { saveCustomAttribute } from '../../api/customApi';
import useToast from '../../../../ui/feedback/useToast';

// Keep options aligned with table
const ATTEST_OPTIONS = ['Meet', 'Partial Meet', 'Does Not Meet'];

/**
 * Props:
 *  - orgID, orgName
 *  - csf2SubcategoryID, subcatName
 *  - existingRows: ALL rows for this org/subcat (unfiltered) — baseline + custom
 *  - onAdded(newRow), onPatched(key, patch), onDeleted(key)
 *
 * newRow shape expected by the table:
 * {
 *   isCustom: true,
 *   orgID, csF2SubcategoryID,
 *   maturityLevel, customAttributeNum,
 *   customAttributeDefinition, customAttributeAttestation
 * }
 */
export default function AddCustomAttributePanel({
  orgID,
  orgName,
  csf2SubcategoryID,
  subcatName,
  existingRows = [],
  onAdded,
  onPatched,
  onDeleted,
}) {
  const { success, error } = useToast();

  // --- compose add form ---
  const [ml, setMl] = React.useState(3);
  const [def, setDef] = React.useState('');
  const [att, setAtt] = React.useState('');
  const [adding, setAdding] = React.useState(false);

  // list derived purely from props (so it updates as soon as parent updates)
  const customRows = React.useMemo(
    () =>
      (existingRows || []).filter(
        r => (r.isCustom || r.customAttributeDefinition) && r.orgID === orgID && r.csF2SubcategoryID === csf2SubcategoryID
      ),
    [existingRows, orgID, csf2SubcategoryID]
  );

  // decide next custom number (client-side) if server doesn't return one
  const nextCustomNum = React.useCallback((mlVal) => {
    const nums = customRows
      .filter(r => Number(r.maturityLevel) === Number(mlVal))
      .map(r => Number(r.customAttributeNum || 0));
    const max = nums.length ? Math.max(...nums) : 0;
    return max + 1;
  }, [customRows]);

  const handleAdd = async () => {
    if (!def.trim()) return;
    setAdding(true);
    const localNum = nextCustomNum(ml);

    try {
      const resp = await saveCustomAttribute({
        action: 'create',
        orgId: orgID,
        csf2SubcategoryId: csf2SubcategoryID,
        maturityLevel: ml,
        attributeNum: localNum,                // server can override; we’ll read back if it returns
        attrDefinition: def.trim(),
        attestation: att || null,
      });

      // Prefer server’s number/echo; otherwise use our local plan
      const serverNum = resp?.customAttributeNum ?? resp?.attributeNum ?? localNum;
      const serverAtt = resp?.attestation ?? att || null;
      const serverDef = resp?.customAttributeDefinition ?? resp?.attrDefinition ?? def.trim();

      onAdded?.({
        isCustom: true,
        orgID,
        csF2SubcategoryID: csf2SubcategoryID,
        maturityLevel: ml,
        customAttributeNum: serverNum,
        customAttributeDefinition: serverDef,
        customAttributeAttestation: serverAtt,
        // keep table happy
        attributeNum: null,
      });

      success('Custom attribute added');
      setDef('');
      setAtt('');
    } catch (e) {
      error('Add failed');
    } finally {
      setAdding(false);
    }
  };

  return (
    <Paper variant="outlined" sx={{ mt: 2, p: 1.5 }}>
      <Stack direction="row" alignItems="center" justifyContent="space-between" sx={{ mb: 1 }}>
        <Typography variant="subtitle2">
          Custom Attributes — {orgName || 'Org'} / {subcatName}
        </Typography>
      </Stack>

      {/* Add row */}
      <Stack
        direction={{ xs: 'column', md: 'row' }}
        spacing={1}
        alignItems={{ md: 'center' }}
        sx={{ mb: 1.5 }}
      >
        <Select
          size="small"
          value={ml}
          onChange={(e) => setMl(Number(e.target.value))}
          sx={{ width: 140 }}
        >
          <MenuItem value={3}>Maturity — 3</MenuItem>
          <MenuItem value={4}>Maturity — 4</MenuItem>
        </Select>

        <TextField
          size="small"
          fullWidth
          placeholder="Attribute definition…"
          value={def}
          onChange={(e) => setDef(e.target.value)}
        />

        <Select
          size="small"
          displayEmpty
          value={att || ''}
          onChange={(e) => setAtt(e.target.value || '')}
          renderValue={(v) => (v ? v : '2025 Attestation — optional')}
          sx={{ width: { xs: '100%', md: 220 } }}
        >
          <MenuItem value=""><em>—</em></MenuItem>
          {ATTEST_OPTIONS.map(o => <MenuItem key={o} value={o}>{o}</MenuItem>)}
        </Select>

        <Button
          variant="contained"
          onClick={handleAdd}
          disabled={adding || !def.trim()}
          sx={{ minWidth: 88 }}
        >
          {adding ? 'Adding…' : 'Add'}
        </Button>
      </Stack>

      <Divider sx={{ my: 1 }} />

      <Typography variant="caption" color="text.secondary" sx={{ display:'block', mb: 0.5 }}>
        Existing custom attributes
      </Typography>

      <Stack spacing={0.75}>
        {customRows.length === 0 ? (
          <Typography variant="body2" color="text.secondary">No custom attributes.</Typography>
        ) : (
          customRows.map((r) => (
            <CustomListItem
              key={`${r.maturityLevel}|${r.customAttributeNum}`}
              row={r}
              onPatched={onPatched}
              onDeleted={onDeleted}
            />
          ))
        )}
      </Stack>
    </Paper>
  );
}

/** A compact row item with inline edit controls (definition + optional attestation). */
function CustomListItem({ row, onPatched, onDeleted }) {
  const { success, error } = useToast();
  const [edit, setEdit] = React.useState(false);
  const [def, setDef] = React.useState(row.customAttributeDefinition || '');
  const [att, setAtt] = React.useState(row.customAttributeAttestation || '');
  const [saving, setSaving] = React.useState(false);

  React.useEffect(() => {
    setDef(row.customAttributeDefinition || '');
    setAtt(row.customAttributeAttestation || '');
  }, [row.customAttributeDefinition, row.customAttributeAttestation]);

  const k = `${row.orgID}|${row.csF2SubcategoryID}|${row.maturityLevel}|${row.customAttributeNum}`;

  const save = async () => {
    setSaving(true);
    try {
      await saveCustomAttribute({
        action: 'update',
        orgId: row.orgID,
        csf2SubcategoryId: row.csF2SubcategoryID,
        maturityLevel: row.maturityLevel,
        attributeNum: row.customAttributeNum,
        attrDefinition: def.trim(),
        attestation: att || null,
      });
      onPatched?.(k, {
        customAttributeDefinition: def.trim(),
        customAttributeAttestation: att || null,
      });
      success('Updated');
      setEdit(false);
    } catch {
      error('Update failed');
    } finally {
      setSaving(false);
    }
  };

  const remove = async () => {
    try {
      await saveCustomAttribute({
        action: 'delete',
        orgId: row.orgID,
        csf2SubcategoryId: row.csF2SubcategoryID,
        maturityLevel: row.maturityLevel,
        attributeNum: row.customAttributeNum,
      });
      onDeleted?.(k);
      success('Deleted');
    } catch {
      error('Delete failed');
    }
  };

  return (
    <Paper variant="outlined" sx={{ p: 1 }}>
      <Stack direction="row" spacing={1} alignItems="center">
        <Chip size="small" label={`ML ${row.maturityLevel}`} />

        {edit ? (
          <>
            <TextField
              size="small"
              fullWidth
              value={def}
              onChange={(e) => setDef(e.target.value)}
            />
            <Select
              size="small"
              displayEmpty
              value={att || ''}
              onChange={(e) => setAtt(e.target.value || '')}
              renderValue={(v) => (v ? v : '2025 Attestation — optional')}
              sx={{ minWidth: 220 }}
            >
              <MenuItem value=""><em>—</em></MenuItem>
              {ATTEST_OPTIONS.map(o => <MenuItem key={o} value={o}>{o}</MenuItem>)}
            </Select>

            <Tooltip title="Save">
              <span>
                <IconButton size="small" onClick={save} disabled={saving || !def.trim()}>
                  <SaveOutlinedIcon fontSize="small" />
                </IconButton>
              </span>
            </Tooltip>
            <Tooltip title="Cancel">
              <IconButton size="small" onClick={() => { setEdit(false); setDef(row.customAttributeDefinition || ''); setAtt(row.customAttributeAttestation || ''); }}>
                <CloseOutlinedIcon fontSize="small" />
              </IconButton>
            </Tooltip>
          </>
        ) : (
          <>
            <Typography variant="body2" sx={{ flex: 1 }}>{row.customAttributeDefinition}</Typography>
            {row.customAttributeAttestation ? (
              <Chip
                size="small"
                label={row.customAttributeAttestation}
                sx={(t) => ({
                  bgcolor:
                    row.customAttributeAttestation === 'Meet' ? t.palette.success.main :
                    row.customAttributeAttestation === 'Partial Meet' ? t.palette.warning.main :
                    t.palette.error.main,
                  color: row.customAttributeAttestation === 'Partial Meet' ? t.palette.common.black : t.palette.common.white,
                  fontWeight: 600
                })}
              />
            ) : (
              <Typography variant="body2" color="text.secondary">—</Typography>
            )}

            <Tooltip title="Edit">
              <IconButton size="small" onClick={() => setEdit(true)}>
                <EditOutlinedIcon fontSize="small" />
              </IconButton>
            </Tooltip>
            <Tooltip title="Delete">
              <IconButton size="small" onClick={remove}>
                <DeleteOutlineOutlinedIcon fontSize="small" />
              </IconButton>
            </Tooltip>
          </>
        )}
      </Stack>
    </Paper>
  );
}
