@echo off
setlocal ENABLEDELAYEDEXPANSION

REM === CONFIG: edit these if your layout differs ===
set "PROJECT_ROOT=%~dp0"
set "PYTHON_EXE=%PROJECT_ROOT%venv\Scripts\python.exe"
set "ENTRY_SCRIPT=%PROJECT_ROOT%run_etl.py"
set "LOG_DIR=%PROJECT_ROOT%logs"

REM === Ensure log folder exists ===
if not exist "%LOG_DIR%" mkdir "%LOG_DIR%"

REM === Build a safe timestamp: YYYYMMDD_HHMMSS ===
for /f "tokens=1-3 delims=/- " %%a in ("%date%") do (
  set "YY=%%c" & set "MM=%%a" & set "DD=%%b"
)
REM Some locales have different date orders; if the above looks wrong, adjust tokens/order.
set "HH=%time:~0,2%" & set "MI=%time:~3,2%" & set "SS=%time:~6,2%"
REM Remove leading space in hour (e.g., " 7" -> "07")
if "%HH:~0,1%"==" " set "HH=0%HH:~1,1%"
set "STAMP=%YY%%MM%%DD%_%HH%%MI%%SS%"

set "RUN_LOG=%LOG_DIR%\etl_%STAMP%.log"

echo Starting ETL at %date% %time% > "%RUN_LOG%"
echo PROJECT_ROOT=%PROJECT_ROOT% >> "%RUN_LOG%"
echo PYTHON_EXE=%PYTHON_EXE% >> "%RUN_LOG%"
echo ENTRY_SCRIPT=%ENTRY_SCRIPT% >> "%RUN_LOG%"

REM === Switch to project directory (so .env & relative paths work) ===
cd /d "%PROJECT_ROOT%"

REM === If your Python code uses python-dotenv, it will read .env automatically.
REM === Otherwise, you could load .env here (left out for simplicity).

REM === Run the ETL and capture stdout/stderr ===
"%PYTHON_EXE%" "%ENTRY_SCRIPT%" 1>>"%RUN_LOG%" 2>>&1
set "EXITCODE=%ERRORLEVEL%"

echo Python exit code: %EXITCODE% >> "%RUN_LOG%"

endlocal & exit /b %EXITCODE%
