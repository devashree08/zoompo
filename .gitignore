// src/features/attributeMapping/pages/AttributeMappingPage.js
import * as React from 'react';
import { Box, Typography, Stack, Button } from '@mui/material';

import AttributeFilterBar from '../components/molecules/AttributeFilterBar';
import TwoPane from '../../../ui/layout/TwoPane';
import BusyOverlay from '../../../ui/feedback/BusyOverlay';

import CsfTree from '../components/organisms/CsfTree';
import RightHeaderComposite from '../components/organisms/RightHeaderComposite';
import OrgTabs from '../components/molecules/OrgTabs';
import AttributeGroupTable, { rowKey as tableRowKey } from '../components/organisms/AttributeGroupTable';
import AddCustomAttributePanel from '../components/molecules/AddCustomAttributePanel';

import { fetchAttributeFeed } from '../api/attributeApi';
import { exportRowsAsCsv } from '../../../ui/data/csvExport';
import { normalizeHeaders, normalizeRows } from '../utils/normalizeFeed';

const initialFilters = {
  functionIds: [],
  categoryIds: [],
  subcatIds: [],
  ownerNames: [],
  custodianNames: [],
  maturity: [],
  finalOnly: false,
  search: ''
};

const keyOf = (r) => `${r.orgID}|${r.csF2SubcategoryID}|${r.maturityLevel}|${r.customAttributeNum ?? r.attributeNum ?? '0'}`;

export default function AttributeMappingPage() {
  const [filters, setFilters] = React.useState(initialFilters);
  const [headers, setHeaders] = React.useState([]);
  const [rows, setRows] = React.useState([]);

  const [selectedSubcatID, setSelectedSubcatID] = React.useState(null);
  const [activeOrgID, setActiveOrgID] = React.useState(null);

  const [initialLoading, setInitialLoading] = React.useState(true);
  const [loadingHeaders, setLoadingHeaders] = React.useState(false);
  const [loadingRows, setLoadingRows] = React.useState(false);

  const mode = selectedSubcatID ? 'detail' : 'browse';

  const loadHeaders = React.useCallback(async () => {
    setLoadingHeaders(true);
    try {
      const resp = await fetchAttributeFeed({
        functionIds:  filters.functionIds,
        categoryIds:  filters.categoryIds,
        subcatIds:    filters.subcatIds,
        ownerNames:   filters.ownerNames,
        custodianNames: filters.custodianNames,
        maturity:     filters.maturity,
        finalOnly:    filters.finalOnly,
        search:       filters.search
      });
      setHeaders(normalizeHeaders(resp.headers || []));
    } finally {
      setLoadingHeaders(false);
      if (initialLoading) setInitialLoading(false);
    }
  }, [filters, initialLoading]);

  const loadRowsForSubcat = React.useCallback(async (subcatID) => {
    if (!subcatID) { setRows([]); return; }
    setLoadingRows(true);
    try {
      const resp = await fetchAttributeFeed({
        functionIds:  filters.functionIds,
        categoryIds:  filters.categoryIds,
        subcatIds:    [subcatID],
        ownerNames:   filters.ownerNames,
        custodianNames: filters.custodianNames,
        maturity:     filters.maturity,
        finalOnly:    false,              // IMPORTANT: we fetch all; finalOnly handled in UI
        search:       filters.search
      });
      setRows(normalizeRows(resp.rows || []));
    } finally {
      setLoadingRows(false);
    }
  }, [filters]);

  React.useEffect(() => { loadHeaders(); }, [
    filters.functionIds, filters.categoryIds, filters.subcatIds,
    filters.ownerNames, filters.custodianNames, filters.maturity,
    filters.finalOnly, filters.search, loadHeaders
  ]);

  React.useEffect(() => { loadRowsForSubcat(selectedSubcatID); }, [selectedSubcatID, loadRowsForSubcat]);

  const orgsForTabs = React.useMemo(() => {
    if (!selectedSubcatID) return [];
    const m = new Map();
    headers
      .filter(h => h.csF2SubcategoryID === selectedSubcatID)
      .forEach(h => m.set(h.orgID, { orgID: h.orgID, orgName: h.orgName }));
    return Array.from(m.values()).sort((a,b) => a.orgID - b.orgID);
  }, [headers, selectedSubcatID]);

  React.useEffect(() => {
    if (!orgsForTabs.length) { setActiveOrgID(null); return; }
    if (!activeOrgID || !orgsForTabs.some(o => o.orgID === activeOrgID)) {
      setActiveOrgID(orgsForTabs[0].orgID);
    }
  }, [orgsForTabs, activeOrgID]);

  const selectedHeader = React.useMemo(() => {
    if (!selectedSubcatID) return null;
    return (
      headers.find(h => h.csF2SubcategoryID === selectedSubcatID && h.orgID === activeOrgID) ||
      headers.find(h => h.csF2SubcategoryID === selectedSubcatID) || null
    );
  }, [headers, selectedSubcatID, activeOrgID]);

  const rowsForSelected = React.useMemo(
    () => rows.filter(r => r.csF2SubcategoryID === selectedSubcatID),
    [rows, selectedSubcatID]
  );

  const rowsForActiveOrg = React.useMemo(
    () => rowsForSelected.filter(r => r.orgID === activeOrgID),
    [rowsForSelected, activeOrgID]
  );

  // FINAL VIEW: hide baseline "Remove" rows; customs (no Status) are kept
  const displayRows = React.useMemo(() => {
    if (!filters.finalOnly) return rowsForActiveOrg;
    return rowsForActiveOrg.filter(r => (r.selectionStatus || '') !== 'Remove');
  }, [rowsForActiveOrg, filters.finalOnly]);

  // -------- optimistic patch / add / delete from children -------
  const onPatchRow = React.useCallback((k, patch) => {
    setRows(prev => prev.map(r => (keyOf(r) === k ? { ...r, ...patch } : r)));
  }, []);

  const onAddCustomRow = React.useCallback((newRow) => {
    // Ensure the shape the table expects
    const shaped = {
      ...newRow,
      isCustom: true,
      attributeDefinition: undefined,
      customAttributeDefinition: newRow.customAttributeDefinition ?? newRow.attrDefinition ?? newRow.attributeDefinition,
      customAttributeAttestation: newRow.customAttributeAttestation ?? newRow.attestation ?? null,
      attributeNum: null,
      // customAttributeNum must exist; caller (panel) should set it
    };
    setRows(prev => [...prev, shaped]);
  }, []);

  const onDeleteRow = React.useCallback((k) => {
    setRows(prev => prev.filter(r => keyOf(r) !== k));
  }, []);

  const handleSelectSubcat = (id) => setSelectedSubcatID(id);
  const handleBack = () => setSelectedSubcatID(null);
  const handleExport = () => rows?.length && exportRowsAsCsv(rows, 'csf-attribute-rows.csv');

  const ownerCsv = React.useMemo(() => {
    const h = headers.find(x => x.csF2SubcategoryID === selectedSubcatID && x.orgID === activeOrgID);
    return h?.owner || '';
  }, [headers, selectedSubcatID, activeOrgID]);

  const custodianCsv = React.useMemo(() => {
    const h = headers.find(x => x.csF2SubcategoryID === selectedSubcatID && x.orgID === activeOrgID);
    return h?.custodian || '';
  }, [headers, selectedSubcatID, activeOrgID]);

  return (
    <Box sx={{ px: { xs: 1, md: 2 }, pb: 3 }}>
      <AttributeFilterBar value={filters} onChange={setFilters} onExport={handleExport} />

      <Box sx={{ mt: 3 }}>
        {mode === 'browse' ? (
          <>
            <Typography variant="subtitle2" color="text.secondary" sx={{ mb: 1 }}>
              CSF 2.0 Structure
            </Typography>
            <CsfTree headers={headers} onSelectSubcat={handleSelectSubcat} selectedSubcatID={null} />
            {loadingHeaders && (
              <Typography variant="caption" color="text.secondary" sx={{ mt: 1, display:'block' }}>
                Loading…
              </Typography>
            )}
          </>
        ) : (
          <TwoPane
            left={
              <>
                <Stack direction="row" alignItems="center" spacing={1} sx={{ mb: 1 }}>
                  <Button size="small" onClick={handleBack}>← Back</Button>
                  <Typography variant="subtitle2" color="text.secondary">CSF 2.0 Structure</Typography>
                </Stack>
                <CsfTree
                  headers={headers}
                  onSelectSubcat={handleSelectSubcat}
                  selectedSubcatID={selectedSubcatID}
                  maxHeight="calc(100vh - 210px)"
                />
              </>
            }
            right={
              !selectedHeader ? (
                <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
                  {loadingRows ? 'Loading…' : 'Select a subcategory from the left to view details.'}
                </Typography>
              ) : (
                <>
                  <RightHeaderComposite
                    header={selectedHeader}
                    associatedRows={rowsForSelected}
                    ownerCsv={ownerCsv}
                    custodianCsv={custodianCsv}
                  />

                  <OrgTabs
                    orgs={orgsForTabs}
                    activeOrgID={activeOrgID}
                    editableOrgID={activeOrgID}
                    onChange={setActiveOrgID}
                  />

                  <AttributeGroupTable
                    rows={displayRows}
                    onPatchRow={onPatchRow}
                    onDeleteRow={onDeleteRow}
                  />

                  <AddCustomAttributePanel
                    orgID={activeOrgID}
                    orgName={orgsForTabs.find(x => x.orgID === activeOrgID)?.orgName}
                    csf2SubcategoryID={selectedSubcatID}
                    subcatName={selectedHeader.csF2SubcategoryName}
                    existingRows={rowsForActiveOrg}   // UNFILTERED so panel shows what you just added
                    onAdded={onAddCustomRow}
                    onPatched={onPatchRow}
                    onDeleted={onDeleteRow}
                  />
                </>
              )
            }
          />
        )}
      </Box>

      <BusyOverlay open={initialLoading} />
    </Box>
  );
}
