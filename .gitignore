import * as React from 'react';
import { Box, Typography, Card, CardContent, Stack, Switch, FormControlLabel } from '@mui/material';
import AttributeFilterBar from '../components/molecules/AttributeFilterBar';
import TwoPane from '../../../ui/layout/TwoPane';
import BusyOverlay from '../../../ui/feedback/BusyOverlay';
import CsfTree from '../components/organisms/CsfTree';
import HeaderInfoPanel from '../components/organisms/HeaderInfoPanel';
import AssociatedCsf11Panel from '../components/organisms/AssociatedCsf11Panel';
import OrgTabs from '../components/molecules/OrgTabs';
import AttributeGroupTable from '../components/organisms/AttributeGroupTable';
import AddCustomAttributePanel from '../components/molecules/AddCustomAttributePanel';
import { fetchAttributeFeed } from '../api/attributeApi';
import { exportRowsAsCsv } from '../../../ui/data/csvExport';
import { normalizeHeaders, normalizeRows } from '../utils/normalizeFeed';

const initialFilters = {
  orgIds: [], functionIds: [], categoryIds: [], subcatIds: [],
  ownerNames: [], custodianNames: [], maturity: [], finalOnly: false, search: ''
};

export default function AttributeMappingPage() {
  const [filters, setFilters] = React.useState(initialFilters);
  const [compareAllOrgs, setCompareAllOrgs] = React.useState(true); // Option A by default
  const [loading, setLoading] = React.useState(false);
  const [headers, setHeaders] = React.useState([]);
  const [rows, setRows] = React.useState([]);
  const [selectedSubcatID, setSelectedSubcatID] = React.useState(null);
  const editingOrgID = filters.orgIds?.[0] || null;

  const loadFeed = React.useCallback(async (withRows = false, subcatIDs = []) => {
    setLoading(true);
    try {
      const orgIdsParam =
        compareAllOrgs ? [] : (editingOrgID ? [editingOrgID] : []);
      const resp = await fetchAttributeFeed({
        orgIds: orgIdsParam,
        functionIds: filters.functionIds,
        categoryIds: filters.categoryIds,
        subcatIds: withRows ? (subcatIDs?.length ? subcatIDs : filters.subcatIds) : [],
        ownerNames: filters.ownerNames,
        custodianNames: filters.custodianNames,
        maturity: filters.maturity,
        finalOnly: filters.finalOnly,
        search: filters.search
      });
      setHeaders(normalizeHeaders(resp.headers || []));
      setRows(normalizeRows(resp.rows || []));
    } finally {
      setLoading(false);
    }
  }, [filters, editingOrgID, compareAllOrgs]);

  React.useEffect(() => { loadFeed(false); }, [loadFeed]);

  const handleSelectSubcat = async (id) => {
    setSelectedSubcatID(id);
    setFilters(f => ({ ...f, subcatIds: [id] }));
    await loadFeed(true, [id]);
  };

  const selectedHeader = React.useMemo(() => {
    if (!selectedSubcatID) return null;
    // pick the first header for that subcat
    return headers.find(h => h.csF2SubcategoryID === selectedSubcatID) || null;
  }, [headers, selectedSubcatID]);

  const orgsForTabs = React.useMemo(() => {
    if (!selectedSubcatID) return [];
    const set = new Map();
    headers
      .filter(h => h.csF2SubcategoryID === selectedSubcatID)
      .forEach(h => set.set(h.orgID, { orgID: h.orgID, orgName: h.orgName }));
    return Array.from(set.values()).sort((a,b)=>a.orgID-b.orgID);
  }, [headers, selectedSubcatID]);

  const [activeOrgID, setActiveOrgID] = React.useState(null);
  React.useEffect(() => {
    const defaultOrg = editingOrgID || orgsForTabs[0]?.orgID || null;
    setActiveOrgID(defaultOrg);
  }, [editingOrgID, orgsForTabs]);

  const rowsForSelected = React.useMemo(() => {
    if (!selectedSubcatID) return [];
    return rows.filter(r => r.csF2SubcategoryID === selectedSubcatID);
  }, [rows, selectedSubcatID]);

  const rowsForActiveOrg = React.useMemo(() => {
    if (!activeOrgID) return [];
    return rowsForSelected.filter(r => r.orgID === activeOrgID);
  }, [rowsForSelected, activeOrgID]);

  const ownerCsv = React.useMemo(() => {
    const h = headers.find(x => x.csF2SubcategoryID === selectedSubcatID && x.orgID === activeOrgID);
    return h?.owner || '';
  }, [headers, selectedSubcatID, activeOrgID]);

  const custCsv = React.useMemo(() => {
    const h = headers.find(x => x.csF2SubcategoryID === selectedSubcatID && x.orgID === activeOrgID);
    return h?.custodian || '';
  }, [headers, selectedSubcatID, activeOrgID]);

  const handleExport = () => rows?.length && exportRowsAsCsv(rows, 'csf-attribute-rows.csv');

  return (
    <Box sx={{ px: { xs: 1, md: 2 }, pb: 3 }}>
      <AttributeFilterBar
        value={filters}
        onChange={(v) => { setFilters(v); setSelectedSubcatID(null); }}
        onExport={handleExport}
      />

      <Box sx={{ display: 'flex', justifyContent: 'flex-end', mb: 1 }}>
        <FormControlLabel
          control={<Switch checked={compareAllOrgs} onChange={(_,v)=>setCompareAllOrgs(v)} />}
          label="Compare all orgs"
        />
      </Box>

      <TwoPane
        left={
          <>
            <Typography variant="subtitle2" color="text.secondary" sx={{ mb: 1 }}>
              CSF 2.0 Structure
            </Typography>
            <CsfTree
              headers={headers}
              onSelectSubcat={handleSelectSubcat}
              selectedSubcatID={selectedSubcatID}
            />
          </>
        }
        right={
          <>
            {!selectedHeader ? (
              <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
                Select a subcategory from the left to view details.
              </Typography>
            ) : (
              <>
                <HeaderInfoPanel
                  header={selectedHeader}
                  ownerCsv={ownerCsv}
                  custodianCsv={custCsv}
                />

                <Card variant="outlined" sx={{ mb: 2 }}>
                  <CardContent>
                    <Stack
                      direction={{ xs:'column', md:'row' }}
                      spacing={2}
                      useFlexGap
                    >
                      <Box sx={{ flex: 1, minWidth: 0 }}>
                        <Typography variant="overline" color="text.secondary">Change Summary</Typography>
                        <Typography variant="body2">{selectedHeader.changeSummary || '—'}</Typography>
                      </Box>
                      <Box sx={{ flex: 1, minWidth: 0 }}>
                        <Typography variant="overline" color="text.secondary">Implementation Examples</Typography>
                        <Typography variant="body2">{selectedHeader.implementationExamples || '—'}</Typography>
                      </Box>
                    </Stack>
                  </CardContent>
                </Card>

                <Stack direction={{ xs:'column', md:'row' }} spacing={2} sx={{ mb: 1 }}>
                  <Box sx={{ flex: 1 }}>
                    <AssociatedCsf11Panel rows={rowsForSelected} />
                  </Box>
                </Stack>

                <OrgTabs
                  orgs={orgsForTabs}
                  activeOrgID={activeOrgID}
                  editableOrgID={editingOrgID}
                  onChange={setActiveOrgID}
                />

                <AttributeGroupTable rows={rowsForActiveOrg} editable={activeOrgID === editingOrgID} />

                <AddCustomAttributePanel
                  orgName={orgsForTabs.find(x => x.orgID === activeOrgID)?.orgName}
                  subcatName={selectedHeader.csF2SubcategoryName}
                  editable={activeOrgID === editingOrgID}
                />
              </>
            )}
          </>
        }
      />

      <BusyOverlay open={loading} />
    </Box>
  );
}
