import React from 'react';
import { Box } from '@mui/material';
import { FilterBar } from '../../../../ui/patterns/FilterBar';
import MultiSelect from '../../../../ui/core/MultiSelect';
import Switch from '../../../../ui/core/Switch';
import { fetchAttributeFilterLookups } from '../../api/attributeApi';

const MATURITY_OPTIONS = [
  { value: 3, label: 'Level 3' },
  { value: 4, label: 'Level 4' },
];

// shallow compare for arrays of primitives (order-insensitive)
const sameSet = (a = [], b = []) => {
  if (a.length !== b.length) return false;
  const A = new Set(a);
  for (const v of b) if (!A.has(v)) return false;
  return true;
};

export default function AttributeFilterBar({ value, onChange, onExport }) {
  const [opts, setOpts] = React.useState({
    orgs: [], functions: [], categories: [], subcategories: [], owners: [], custodians: []
  });

  // Load lookups for the current filter slice
  React.useEffect(() => {
    let ignore = false;
    (async () => {
      const data = await fetchAttributeFilterLookups({
        orgIds: value.orgIds,
        functionIds: value.functionIds,
        categoryIds: value.categoryIds,
        subcatIds: value.subcatIds,
        ownerNames: value.ownerNames,
        custodianNames: value.custodianNames,
      });
      if (ignore) return;

      // Map EXACT camelCase keys from your API
      const mapped = {
        orgs:          (data.orgs || []).map(x => ({ value: x.orgID,            label: x.orgName })),
        functions:     (data.functions || []).map(x => ({ value: x.functionID,   label: x.functionName })),
        categories:    (data.categories || []).map(x => ({ value: x.categoryID,  label: x.categoryName })),
        subcategories: (data.subcategories || []).map(x => ({ value: x.csF2SubcategoryID, label: x.subcategoryName })),
        owners:        (data.owners || []).map(x => ({ value: x.fullName,        label: x.fullName })),
        custodians:    (data.custodians || []).map(x => ({ value: x.fullName,    label: x.fullName })),
      };
      setOpts(mapped);

      // ---- PRUNE stale selections when upstream changes ----
      const allow = {
        orgIds:          new Set(mapped.orgs.map(o => o.value)),
        functionIds:     new Set(mapped.functions.map(o => o.value)),
        categoryIds:     new Set(mapped.categories.map(o => o.value)),
        subcatIds:       new Set(mapped.subcategories.map(o => o.value)),
        ownerNames:      new Set(mapped.owners.map(o => o.value)),
        custodianNames:  new Set(mapped.custodians.map(o => o.value)),
      };

      const pruned = {
        ...value,
        orgIds:         value.orgIds.filter(v => allow.orgIds.has(v)),
        functionIds:    value.functionIds.filter(v => allow.functionIds.has(v)),
        categoryIds:    value.categoryIds.filter(v => allow.categoryIds.has(v)),
        subcatIds:      value.subcatIds.filter(v => allow.subcatIds.has(v)),
        ownerNames:     value.ownerNames.filter(v => allow.ownerNames.has(v)),
        custodianNames: value.custodianNames.filter(v => allow.custodianNames.has(v)),
      };

      // Only push if anything actually changed (avoid loops)
      if (
        !sameSet(pruned.orgIds, value.orgIds) ||
        !sameSet(pruned.functionIds, value.functionIds) ||
        !sameSet(pruned.categoryIds, value.categoryIds) ||
        !sameSet(pruned.subcatIds, value.subcatIds) ||
        !sameSet(pruned.ownerNames, value.ownerNames) ||
        !sameSet(pruned.custodianNames, value.custodianNames)
      ) {
        onChange(pruned);
      }
    })();
    return () => { ignore = true; };
  // Trigger when *selections* change (not on opts change to avoid loops)
  }, [value.orgIds, value.functionIds, value.categoryIds, value.subcatIds, value.ownerNames, value.custodianNames]);

  // Auto-fit grid so filters breathe on tablets â†’ monitors
  const filtersLayout = (
    <Box
      sx={{
        display: 'grid',
        gridTemplateColumns: 'repeat(auto-fit, minmax(220px, 1fr))',
        gap: 1.5,
        alignItems: 'center',
      }}
    >
      <MultiSelect label="Organizations" value={value.orgIds}
        onChange={(v) => onChange({ ...value, orgIds: v })}
        options={opts.orgs} />

      <MultiSelect label="Functions" value={value.functionIds}
        onChange={(v) => onChange({ ...value, functionIds: v })}
        options={opts.functions} />

      <MultiSelect label="Categories" value={value.categoryIds}
        onChange={(v) => onChange({ ...value, categoryIds: v })}
        options={opts.categories} />

      <MultiSelect label="Subcategories" value={value.subcatIds}
        onChange={(v) => onChange({ ...value, subcatIds: v })}
        options={opts.subcategories} />

      <MultiSelect label="Owners" value={value.ownerNames}
        onChange={(v) => onChange({ ...value, ownerNames: v })}
        options={opts.owners} />

      <MultiSelect label="Custodians" value={value.custodianNames}
        onChange={(v) => onChange({ ...value, custodianNames: v })}
        options={opts.custodians} />

      <MultiSelect label="Maturity" value={value.maturity}
        onChange={(v) => onChange({ ...value, maturity: v })}
        options={MATURITY_OPTIONS} />

      <Switch
        label="Final view (hide Removed)"
        checked={!!value.finalOnly}
        onChange={(checked) => onChange({ ...value, finalOnly: checked })}
      />
    </Box>
  );

  return (
    <FilterBar
      filtersLeft={filtersLayout}
      searchValue={value.search}
      onSearchChange={(s) => onChange({ ...value, search: s })}
      onExport={onExport}
      exportLabel="Export"
    />
  );
}
