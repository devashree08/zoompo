/* =========================================================
   3) CREATE
   Purpose: Insert a new tag; auto-assign SortOrder (5,10,15â€¦ per list)
   Params:  @ListName, @TagValue, @User (optional)
   Returns: NewTagID, AssignedSortOrder
   Notes:   Uses TRAN + UPDLOCK/HOLDLOCK to avoid race conditions;
            also checks duplicate active value (unique filtered index will enforce too)
   ========================================================= */
CREATE OR ALTER PROC dbo.usp_SelectionTag_Create
  @ListName  NVARCHAR(64),
  @TagValue  NVARCHAR(128),
  @User      NVARCHAR(128) = NULL
AS
BEGIN
  SET NOCOUNT ON;
  SET XACT_ABORT ON;

  BEGIN TRY
    BEGIN TRAN;

    -- Friendly dup check (per-list, active only)
    IF EXISTS (
      SELECT 1
      FROM dbo.SelectionTag WITH (UPDLOCK, HOLDLOCK)
      WHERE ListName = @ListName AND TagValue = @TagValue AND IsActive = 1
    )
      THROW 50050, 'Duplicate active tag value in this list.', 1;

    -- Allocate next SortOrder safely per list
    DECLARE @NextSort INT;
    SELECT @NextSort = ISNULL(MAX(SortOrder), 0) + 5
    FROM dbo.SelectionTag WITH (UPDLOCK, HOLDLOCK)
    WHERE ListName = @ListName;

    INSERT INTO dbo.SelectionTag (ListName, TagValue, IsActive, SortOrder, CreatedBy, UpdatedBy)
    VALUES (@ListName, @TagValue, 1, @NextSort, COALESCE(@User, SUSER_SNAME()), COALESCE(@User, SUSER_SNAME()));

    DECLARE @NewID INT = SCOPE_IDENTITY();

    COMMIT TRAN;

    SELECT @NewID AS NewTagID, @NextSort AS AssignedSortOrder;
  END TRY
  BEGIN CATCH
    IF XACT_STATE() <> 0 ROLLBACK TRAN;
    THROW 50051, ERROR_MESSAGE(), 1;
  END CATCH
END
GO



/* =========================================================
   4) UPDATE
   Purpose: Rename a tag and/or toggle active flag (backend owns SortOrder)
   Params:  @TagID, @NewTagValue (nullable), @IsActive (nullable), @User (optional)
   Returns: Updated row
   Notes:   Uses TRAN; prevents duplicate active values within a list
   ========================================================= */
CREATE OR ALTER PROC dbo.usp_SelectionTag_Update
  @TagID       INT,
  @NewTagValue NVARCHAR(128) = NULL,
  @IsActive    BIT           = NULL,
  @User        NVARCHAR(128) = NULL
AS
BEGIN
  SET NOCOUNT ON;
  SET XACT_ABORT ON;

  BEGIN TRY
    BEGIN TRAN;

    DECLARE @ListName NVARCHAR(64), @CurValue NVARCHAR(128), @CurActive BIT;
    SELECT @ListName = ListName, @CurValue = TagValue, @CurActive = IsActive
    FROM dbo.SelectionTag WITH (UPDLOCK, HOLDLOCK)
    WHERE TagID = @TagID;

    IF @ListName IS NULL
      THROW 50052, 'Update failed: Tag not found.', 1;

    DECLARE @FinalValue  NVARCHAR(128) = COALESCE(@NewTagValue, @CurValue);
    DECLARE @FinalActive BIT           = COALESCE(@IsActive,    @CurActive);

    IF @FinalActive = 1 AND EXISTS (
      SELECT 1
      FROM dbo.SelectionTag WITH (UPDLOCK, HOLDLOCK)
      WHERE ListName = @ListName
        AND TagValue = @FinalValue
        AND IsActive = 1
        AND TagID <> @TagID
    )
      THROW 50053, 'Duplicate active tag value in this list.', 1;

    UPDATE dbo.SelectionTag
       SET TagValue  = @FinalValue,
           IsActive  = @FinalActive,
           UpdatedAt = SYSUTCDATETIME(),
           UpdatedBy = COALESCE(@User, SUSER_SNAME())
     WHERE TagID = @TagID;

    COMMIT TRAN;

    SELECT TagID, ListName, TagValue, IsActive, SortOrder, UpdatedAt, UpdatedBy
    FROM dbo.SelectionTag WHERE TagID = @TagID;
  END TRY
  BEGIN CATCH
    IF XACT_STATE() <> 0 ROLLBACK TRAN;
    THROW 50054, ERROR_MESSAGE(), 1;
  END CATCH
END
GO

/* =========================================================
   5) SOFT DELETE
   Purpose: Mark a tag inactive (soft delete)
   Params:  @TagID, @User (optional)
   Returns: Updated row
   Notes:   Uses TRAN
   ========================================================= */
CREATE OR ALTER PROC dbo.usp_SelectionTag_SoftDelete
  @TagID INT,
  @User  NVARCHAR(128) = NULL
AS
BEGIN
  SET NOCOUNT ON;
  SET XACT_ABORT ON;

  BEGIN TRY
    BEGIN TRAN;

    UPDATE dbo.SelectionTag
       SET IsActive  = 0,
           UpdatedAt = SYSUTCDATETIME(),
           UpdatedBy = COALESCE(@User, SUSER_SNAME())
     WHERE TagID = @TagID;

    IF @@ROWCOUNT = 0
      THROW 50055, 'Soft delete failed: Tag not found.', 1;

    COMMIT TRAN;

    SELECT TagID, ListName, TagValue, IsActive, SortOrder, UpdatedAt, UpdatedBy
    FROM dbo.SelectionTag WHERE TagID = @TagID;
  END TRY
  BEGIN CATCH
    IF XACT_STATE() <> 0 ROLLBACK TRAN;
    THROW 50056, ERROR_MESSAGE(), 1;
  END CATCH
END
GO


/* =========================================================
   6) RESTORE
   Purpose: Reactivate a previously soft-deleted tag
   Params:  @TagID, @User (optional)
   Returns: Updated row
   Notes:   Uses TRAN; blocks restore if it would duplicate an active value
   ========================================================= */
CREATE OR ALTER PROC dbo.usp_SelectionTag_Restore
  @TagID INT,
  @User  NVARCHAR(128) = NULL
AS
BEGIN
  SET NOCOUNT ON;
  SET XACT_ABORT ON;

  BEGIN TRY
    BEGIN TRAN;

    DECLARE @ListName NVARCHAR(64), @TagValue NVARCHAR(128);
    SELECT @ListName = ListName, @TagValue = TagValue
    FROM dbo.SelectionTag WITH (UPDLOCK, HOLDLOCK)
    WHERE TagID = @TagID;

    IF @ListName IS NULL
      THROW 50057, 'Restore failed: Tag not found.', 1;

    IF EXISTS (
      SELECT 1
      FROM dbo.SelectionTag WITH (UPDLOCK, HOLDLOCK)
      WHERE ListName = @ListName
        AND TagValue = @TagValue
        AND IsActive = 1
        AND TagID <> @TagID
    )
      THROW 50058, 'Restore would duplicate an active tag in this list.', 1;

    UPDATE dbo.SelectionTag
       SET IsActive  = 1,
           UpdatedAt = SYSUTCDATETIME(),
           UpdatedBy = COALESCE(@User, SUSER_SNAME())
     WHERE TagID = @TagID;

    COMMIT TRAN;

    SELECT TagID, ListName, TagValue, IsActive, SortOrder, UpdatedAt, UpdatedBy
    FROM dbo.SelectionTag WHERE TagID = @TagID;
  END TRY
  BEGIN CATCH
    IF XACT_STATE() <> 0 ROLLBACK TRAN;
    THROW 50059, ERROR_MESSAGE(), 1;
  END CATCH
END
GO


