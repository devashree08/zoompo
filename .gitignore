import { createWorkbook, autoFitColumns } from '../../../ui/data/xlsx/excel';

// Styles
const solid = (argb) => ({ type: 'pattern', pattern: 'solid', fgColor: { argb } });
const WHITE_BOLD = { color: { argb: 'FFFFFFFF' }, bold: true };
const BOLD = { bold: true };

// Header fills
const HDR_BASE_FILL   = 'FF2F3A4A'; // dark band for all headers (better for exec visuals)
const HDR_STATUS_HINT = 'FFECFDF3'; // subtle hint for editable columns
const HDR_ATTEST_HINT = 'FFFFFAEB';

// Attestation deep colors
function colorAttestation(cell, v) {
  if (v === 'Meet')          { cell.fill = solid('FF12B76A'); cell.font = WHITE_BOLD; }
  else if (v === 'Partial Meet' || v === 'Partially Meet') { cell.fill = solid('FFF79009'); cell.font = { bold: true }; }
  else if (v === 'Does Not Meet') { cell.fill = solid('FFD92D20'); cell.font = WHITE_BOLD; }
}

// Excel-safe sheet names
function safeSheetName(name) {
  const cleaned = (name || 'Org')
    .replace(/[\[\]\:\*\?\/\\]/g, ' ')
    .slice(0, 31)
    .trim();
  return cleaned || 'Org';
}

// Match UI sort: CSF2 → CSF1 (0/custom last) → baseline → custom → ML (3 then 4) → Attr#
function sortRowsLikeTable(a, b) {
  if (a.csF2SubcategoryID !== b.csF2SubcategoryID)
    return a.csF2SubcategoryID - b.csF2SubcategoryID;

  const aKey = a.csF1SubcategoryID || 999999;
  const bKey = b.csF1SubcategoryID || 999999;
  if (aKey !== bKey) return aKey - bKey;

  const aIsCustom = !!a.customAttributeDefinition;
  const bIsCustom = !!b.customAttributeDefinition;
  if (aIsCustom !== bIsCustom) return aIsCustom ? 1 : -1;

  if (a.maturityLevel !== b.maturityLevel) return a.maturityLevel - b.maturityLevel;

  const aNum = a.attributeNum || a.customAttributeNum || 999999;
  const bNum = b.attributeNum || b.customAttributeNum || 999999;
  return aNum - bNum;
}

function getColumns() {
  return [
    { header: 'Function',                key: 'functionName'              },
    { header: 'Function Language',       key: 'functionLanguage'          },
    { header: 'Category',                key: 'categoryName'              },
    { header: 'Category Language',       key: 'categoryLanguage'          },
    { header: 'CSF 2.0 Subcategory',     key: 'csf2Name'                  },
    { header: 'Subcategory Language',    key: 'csf2Lang'                  },
    { header: 'Change Summary',          key: 'changeSummary'             },
    { header: 'Implementation Examples', key: 'implementationExamples'    },

    { header: 'Associated NIST 1.1',     key: 'csf1Name'                  },
    { header: 'Type',                    key: 'type'                      }, // Baseline | Custom

    { header: 'ML',                      key: 'ml'                        }, // numeric only
    { header: 'Attr #',                  key: 'attrNum'                   },
    { header: 'Attribute Definition',    key: 'attrDef'                   },

    { header: 'Status',                  key: 'status'                    }, // editable
    { header: '2025 Attestation',        key: 'attestation'               }, // editable
    { header: '2024 Assessor Score',     key: 'assess2024'                },

    { header: 'Owner(s)',                key: 'owner'                     },
    { header: 'Custodian(s)',            key: 'custodian'                 },
  ];
}

export async function buildAttributeWorkbook({ headers = [], rows = [] }) {
  const wb = createWorkbook();

  // Group rows by org
  const byOrg = new Map();
  rows.forEach(r => {
    const k = `${r.orgID}|${r.orgName}`;
    if (!byOrg.has(k)) byOrg.set(k, []);
    byOrg.get(k).push(r);
  });

  // Pre-index headers by (org, csf2SubcatID) for context
  const headersIndex = new Map(); // key: `${orgID}|${csf2Id}` → header
  headers.forEach(h => {
    headersIndex.set(`${h.orgID}|${h.csF2SubcategoryID}`, h);
  });

  for (const [orgKey, orgRows] of byOrg.entries()) {
    const [, orgName] = orgKey.split('|');
    const ws = wb.addWorksheet(safeSheetName(orgName));

    ws.columns = getColumns();

    // Frozen header row
    ws.views = [{ state: 'frozen', ySplit: 1 }];
    const hdr = ws.getRow(1);
    hdr.height = 22;
    hdr.font = { bold: true, color: { argb: 'FFFFFFFF' } };
    hdr.alignment = { vertical: 'middle', horizontal: 'center', wrapText: true };
    hdr.eachCell((cell, i) => {
      cell.fill = solid(HDR_BASE_FILL);
      // add thin bottom border for a crisp band
      cell.border = { bottom: { style: 'thin', color: { argb: 'FFFFFFFF' } } };

      const key = ws.columns[i - 1]?.key;
      if (key === 'status') {
        // put a subtle underlay to hint "editable"
        cell.note = 'Editable in portal';
        // caller asked: headers “different and sticky”; base band is enough visually
        // (we keep the dark band, no need to recolor the cell itself)
      }
      if (key === 'attestation') {
        cell.note = 'Editable in portal';
      }
    });

    // Sort to match UI
    orgRows.sort(sortRowsLikeTable);

    // Add rows
    orgRows.forEach(r => {
      const isCustom = !!r.customAttributeDefinition;
      const ctx = headersIndex.get(`${r.orgID}|${r.csF2SubcategoryID}`) || r;

      const attrDef = r.attributeDefinition || r.customAttributeDefinition || '';
      const attrNum = r.attributeNum || r.customAttributeNum || '';
      const att     = r.selectionAttestation || r.customAttributeAttestation || '';
      const status  = isCustom ? '' : (r.selectionStatus || '');

      const row = ws.addRow({
        functionName:             r.functionName,
        functionLanguage:         r.functionLanguage,
        categoryName:             r.categoryName,
        categoryLanguage:         r.categoryLanguage,
        csf2Name:                 r.csF2SubcategoryName,
        csf2Lang:                 r.csF2SubcategoryLanguage,
        changeSummary:            ctx.changeSummary || r.changeSummary,
        implementationExamples:   ctx.implementationExamples || r.implementationExamples,

        csf1Name:                 r.csF1SubcategoryName || '',
        type:                     isCustom ? 'Custom' : 'Baseline',
        ml:                       r.maturityLevel,
        attrNum:                  attrNum,
        attrDef:                  attrDef,

        status:                   status,
        attestation:              att,
        assess2024:               r.assessScore2024 || '',

        owner:                    r.owner || '',
        custodian:                r.custodian || '',
      });

      // Wrap long text
      row.getCell('changeSummary').alignment = { wrapText: true };
      row.getCell('implementationExamples').alignment = { wrapText: true };
      row.getCell('attrDef').alignment = { wrapText: true };
      row.getCell('ml').alignment = { horizontal: 'center' };

      // Color Status values (baseline only)
      const stCell = row.getCell('status');
      if (stCell.value === 'Keep') {
        stCell.fill = solid('FFECFDF3');
        stCell.font = { color: { argb: 'FF027A48' }, bold: true };
      } else if (stCell.value === 'Remove') {
        stCell.fill = solid('FFFEF3F2');
        stCell.font = { color: { argb: 'FF912018' }, bold: true };
      }

      // Deep color for Attestation
      colorAttestation(row.getCell('attestation'), att);

      // Custom attribute: tint the definition cell
      if (isCustom) {
        row.getCell('attrDef').fill = solid('FFE3F2FD');
      }
    });

    autoFitColumns(ws, { min: 8, max: 100 });
  }

  return wb;
}
