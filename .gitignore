// src/features/attributeMapping/pages/AttributeMappingPage.js
import * as React from 'react';
import { Box, Typography, Stack, Button } from '@mui/material';

import AttributeFilterBar from '../components/molecules/AttributeFilterBar';
import TwoPane from '../../../ui/layout/TwoPane';
import BusyOverlay from '../../../ui/feedback/BusyOverlay';

import CsfTree from '../components/organisms/CsfTree';
import RightHeaderComposite from '../components/organisms/RightHeaderComposite';
import OrgTabs from '../components/molecules/OrgTabs';
import AttributeGroupTable from '../components/organisms/AttributeGroupTable';
import AddCustomAttributePanel from '../components/molecules/AddCustomAttributePanel';

import { fetchAttributeFeed } from '../api/attributeApi';
import { exportRowsAsCsv } from '../../../ui/data/csvExport';
import { normalizeHeaders, normalizeRows } from '../utils/normalizeFeed';

const initialFilters = {
  functionIds: [],
  categoryIds: [],
  subcatIds: [],
  ownerNames: [],
  custodianNames: [],
  maturity: [],
  finalOnly: false,
  search: ''
};

const keyOf = (r) =>
  `${r.orgID}|${r.csF2SubcategoryID}|${r.maturityLevel}|${r.customAttributeNum ?? r.attributeNum ?? '0'}`;

export default function AttributeMappingPage() {
  // filters & data
  const [filters, setFilters] = React.useState(initialFilters);
  const [headers, setHeaders] = React.useState([]);
  const [rows, setRows] = React.useState([]);

  // selection state
  const [selectedSubcatID, setSelectedSubcatID] = React.useState(null);
  const [activeOrgID, setActiveOrgID] = React.useState(null);

  // loading flags
  const [initialLoading, setInitialLoading] = React.useState(true);
  const [loadingHeaders, setLoadingHeaders] = React.useState(false);
  const [loadingRows, setLoadingRows] = React.useState(false);

  const mode = selectedSubcatID ? 'detail' : 'browse';

  // ------------- HEADERS (all orgs, for tree + tabs) -------------
  const loadHeaders = React.useCallback(async () => {
    setLoadingHeaders(true);
    try {
      const resp = await fetchAttributeFeed({
        functionIds:     filters.functionIds,
        categoryIds:     filters.categoryIds,
        subcatIds:       filters.subcatIds,
        ownerNames:      filters.ownerNames,
        custodianNames:  filters.custodianNames,
        maturity:        filters.maturity,
        finalOnly:       filters.finalOnly,
        search:          filters.search
      });
      setHeaders(normalizeHeaders(resp.headers || []));
    } finally {
      setLoadingHeaders(false);
      if (initialLoading) setInitialLoading(false);
    }
  }, [filters, initialLoading]);

  React.useEffect(() => { loadHeaders(); }, [
    filters.functionIds, filters.categoryIds, filters.subcatIds,
    filters.ownerNames, filters.custodianNames, filters.maturity,
    filters.finalOnly, filters.search, loadHeaders
  ]);

  // Derive tabs (orgs available for the selected subcategory)
  const orgsForTabs = React.useMemo(() => {
    if (!selectedSubcatID) return [];
    const m = new Map();
    headers
      .filter(h => String(h.csF2SubcategoryID) === String(selectedSubcatID))
      .forEach(h => m.set(h.orgID, { orgID: h.orgID, orgName: h.orgName }));
    return Array.from(m.values()).sort((a,b) => a.orgID - b.orgID);
  }, [headers, selectedSubcatID]);

  React.useEffect(() => {
    if (!orgsForTabs.length) { setActiveOrgID(null); return; }
    if (!activeOrgID || !orgsForTabs.some(o => o.orgID === activeOrgID)) {
      setActiveOrgID(orgsForTabs[0].orgID);
    }
  }, [orgsForTabs, activeOrgID]);

  // ------------- ROWS (scoped to active org) with race guard -------------
  const rowsReqSeq = React.useRef(0); // increments per request

  const loadRowsForSubcat = React.useCallback(async (subcatID, orgId) => {
    // Clear immediately to avoid showing stale rows during tab switch
    setRows([]);
    if (!subcatID || !orgId) return;

    setLoadingRows(true);
    const mySeq = ++rowsReqSeq.current; // capture my request id
    try {
      const resp = await fetchAttributeFeed({
        orgIds:          [orgId],               // IMPORTANT: scope rows to active org
        functionIds:     filters.functionIds,
        categoryIds:     filters.categoryIds,
        subcatIds:       [subcatID],
        ownerNames:      filters.ownerNames,
        custodianNames:  filters.custodianNames,
        maturity:        filters.maturity,
        finalOnly:       filters.finalOnly,
        search:          filters.search
      });

      // Only the latest request may update rows
      if (mySeq === rowsReqSeq.current) {
        setRows(normalizeRows(resp.rows || []));
      }
    } finally {
      // Only clear loading if we are still the latest request
      if (mySeq === rowsReqSeq.current) {
        setLoadingRows(false);
      }
    }
  }, [filters]);

  // (re)load rows whenever subcategory OR active org changes
  React.useEffect(() => {
    loadRowsForSubcat(selectedSubcatID, activeOrgID);
  }, [selectedSubcatID, activeOrgID, loadRowsForSubcat]);

  // Owner/Custodian for header (org-scoped)
  const ownerCsv = React.useMemo(() => {
    const h = headers.find(x =>
      String(x.csF2SubcategoryID) === String(selectedSubcatID) &&
      x.orgID === activeOrgID);
    return h?.owner || '';
  }, [headers, selectedSubcatID, activeOrgID]);

  const custodianCsv = React.useMemo(() => {
    const h = headers.find(x =>
      String(x.csF2SubcategoryID) === String(selectedSubcatID) &&
      x.orgID === activeOrgID);
    return h?.custodian || '';
  }, [headers, selectedSubcatID, activeOrgID]);

  // Header card wants a single header row for the active org, fallback to any
  const selectedHeader = React.useMemo(() => {
    if (!selectedSubcatID) return null;
    return (
      headers.find(h => String(h.csF2SubcategoryID) === String(selectedSubcatID) && h.orgID === activeOrgID) ||
      headers.find(h => String(h.csF2SubcategoryID) === String(selectedSubcatID)) || null
    );
  }, [headers, selectedSubcatID, activeOrgID]);

  // Apply “Final View” locally (hide Remove)
  const displayRows = React.useMemo(() => {
    if (!filters.finalOnly) return rows;
    return rows.filter(r => (r.selectionStatus || '') !== 'Remove');
  }, [rows, filters.finalOnly]);

  // -------- optimistic patch hooks (table/panel) --------
  const onPatchRow = React.useCallback((k, patch) => {
    setRows(prev => prev.map(r => (keyOf(r) === k ? { ...r, ...patch } : r)));
  }, []);

  const onAddCustomRow = React.useCallback((newRow) => {
    setRows(prev => [...prev, newRow]);
  }, []);

  const onDeleteRow = React.useCallback((k) => {
    setRows(prev => prev.filter(r => keyOf(r) !== k));
  }, []);

  // -------- handlers --------
  const handleSelectSubcat = (id) => setSelectedSubcatID(id);
  const handleBack = () => setSelectedSubcatID(null);
  const handleExport = () => displayRows?.length && exportRowsAsCsv(displayRows, 'csf-attribute-rows.csv');

  // -------- render --------
  return (
    <Box sx={{ px: { xs: 1, md: 2 }, pb: 3 }}>
      <AttributeFilterBar value={filters} onChange={setFilters} onExport={handleExport} />

      <Box sx={{ mt: 3 }}>
        {mode === 'browse' ? (
          <>
            <Typography variant="subtitle2" color="text.secondary" sx={{ mb: 1 }}>
              CSF 2.0 Attribute Mapping
            </Typography>
            <CsfTree
              headers={headers}
              onSelectSubcat={handleSelectSubcat}
              selectedSubcatID={null}
            />
            {loadingHeaders && (
              <Typography variant="caption" color="text.secondary" sx={{ mt: 1, display:'block' }}>
                Loading…
              </Typography>
            )}
          </>
        ) : (
          <TwoPane
            left={
              <>
                <Stack direction="row" alignItems="center" spacing={1} sx={{ mb: 1 }}>
                  <Button size="small" onClick={handleBack}>← Back</Button>
                  <Typography variant="subtitle2" color="text.secondary">CSF 2.0 Structure</Typography>
                </Stack>
                <CsfTree
                  headers={headers}
                  onSelectSubcat={handleSelectSubcat}
                  selectedSubcatID={selectedSubcatID}
                  maxHeight="calc(100vh - 210px)"
                />
              </>
            }
            right={
              !selectedHeader ? (
                <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
                  {loadingRows ? 'Loading…' : 'Select a subcategory from the left to view details.'}
                </Typography>
              ) : (
                <>
                  <RightHeaderComposite
                    header={selectedHeader}
                    associatedRows={rows}    // rows are org-scoped; OK for assoc panel
                    ownerCsv={ownerCsv}
                    custodianCsv={custodianCsv}
                  />

                  <OrgTabs
                    orgs={orgsForTabs}
                    activeOrgID={activeOrgID}
                    editableOrgID={activeOrgID}
                    onChange={setActiveOrgID}
                  />

                  <AttributeGroupTable
                    rows={displayRows}
                    onPatchRow={onPatchRow}
                    onDeleteRow={onDeleteRow}
                    maxHeight="50ch"
                  />

                  <AddCustomAttributePanel
                    orgID={activeOrgID}
                    orgName={orgsForTabs.find(x => x.orgID === activeOrgID)?.orgName}
                    csf2SubcategoryID={selectedSubcatID}
                    subcatName={selectedHeader.csF2SubcategoryName}
                    existingRows={rows}           // current org’s rows
                    onAdded={onAddCustomRow}
                    onPatched={onPatchRow}
                    onDeleted={onDeleteRow}
                  />
                </>
              )
            }
          />
        )}
      </Box>

      <BusyOverlay open={initialLoading} />
    </Box>
  );
}
