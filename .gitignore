using System.Data;
using Dapper;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Caching.Memory;

namespace Gef.Portal.Services;

public sealed class PortalPolicyService : IPortalPolicyService
{
    private readonly GEF_DbContext _db;
    private readonly IMemoryCache _cache;
    private static readonly TimeSpan CacheTtl = TimeSpan.FromMinutes(5);

    public PortalPolicyService(GEF_DbContext db, IMemoryCache cache)
    {
        _db = db;
        _cache = cache;
    }

    public async Task<IReadOnlyList<string>> GetPoliciesAsync(
        string? eid,
        string? userName,
        CancellationToken ct = default)
    {
        // Prefer EID, fallback to username
        var cacheKey = $"policies::{eid ?? userName ?? "anon"}";
        if (_cache.TryGetValue(cacheKey, out IReadOnlyList<string>? cached))
            return cached;

        await using var conn = _db.Database.GetDbConnection();
        if (conn.State != ConnectionState.Open) await conn.OpenAsync(ct);

        var p = new DynamicParameters();
        p.Add("@UserEID",  eid,      DbType.String);
        p.Add("@UserName", userName, DbType.String);

        // Calls Phase-1 SP (row-per-policy). Zero rows means "read-only".
        var rows = await conn.QueryAsync<string>(
            sql: "dbo.usp_PortalPolicies_GetForUser",
            param: p,
            commandType: CommandType.StoredProcedure);

        var list = rows.ToList().AsReadOnly();

        _cache.Set(cacheKey, list, CacheTtl);
        return list;
    }
}
