const upsertRow = React.useCallback((newRow) => {
  setRows(prev => {
    const key = `${newRow.orgID}|${newRow.csF2SubcategoryID}|${newRow.maturityLevel}|${newRow.attributeNum}`;
    const idx = prev.findIndex(r => (
      r.orgID === newRow.orgID &&
      r.csF2SubcategoryID === newRow.csF2SubcategoryID &&
      r.maturityLevel === newRow.maturityLevel &&
      r.attributeNum === newRow.attributeNum
    ));
    if (idx >= 0) {
      const copy = prev.slice(); copy[idx] = { ...prev[idx], ...newRow }; return copy;
    }
    return [...prev, newRow].sort((a,b) =>
      (a.maturityLevel - b.maturityLevel) || (a.attributeNum - b.attributeNum)
    );
  });
}, []);

const removeRow = React.useCallback((rowKeyStr) => {
  setRows(prev => prev.filter(r =>
    `${r.orgID}|${r.csF2SubcategoryID}|${r.maturityLevel}|${r.attributeNum}` !== rowKeyStr
  ));
}, []);


---
import * as React from 'react';
import {
  Box, Paper, Stack, TextField, Select, MenuItem, Button, Typography, IconButton, Tooltip, Dialog, DialogTitle, DialogContent, DialogActions, Chip
} from '@mui/material';
import EditRoundedIcon from '@mui/icons-material/EditRounded';
import DeleteOutlineRoundedIcon from '@mui/icons-material/DeleteOutlineRounded';
import { alpha } from '@mui/material/styles';

import { saveCustomAttribute } from '../../api/customApi';
import useToast from '../../../../ui/feedback/useToast';

const ATTEST_OPTIONS = ['Meet', 'Partial Meet', 'Does Not Meet'];
const ML_OPTIONS = [3,4];

// Helper to build the same row key your table uses
const rowKey = (r) => `${r.orgID}|${r.csF2SubcategoryID}|${r.maturityLevel}|${r.attributeNum}`;

/** Fallback: next attributeNum when backend doesn't assign one.
 *  Start at 15 (your rule) and increment.
 */
function nextCustomAttrNum(existingRows) {
  const customs = existingRows.filter(r => Number(r.csF1SubcategoryID) === 0);
  if (!customs.length) return 15;
  const max = Math.max(...customs.map(r => Number(r.attributeNum) || 0), 14);
  return max + 1;
}

/** Turn an API result + input into a row object your table can consume. */
function toRow({
  orgID, csF2SubcategoryID, maturityLevel, attributeNum, attributeDefinition, attestation,
  base // optional: use to inherit static fields like names/language
}) {
  return {
    // keys
    orgID,
    csF2SubcategoryID,
    csF1SubcategoryID: 0,                     // customs = 0 in your feed
    maturityLevel,
    attributeNum,

    // table fields
    attributeDefinition: null,                 // baseline column
    customAttributeDefinition: attributeDefinition,
    selectionStatus: null,                     // not applicable at add time
    selectionAttestation: attestation || null,

    // static (nullable) carried from base
    orgName: base?.orgName,
    functionID: base?.functionID,
    functionName: base?.functionName,
    functionLanguage: base?.functionLanguage,
    categoryID: base?.categoryID,
    categoryName: base?.categoryName,
    categoryLanguage: base?.categoryLanguage,
    csF2SubcategoryName: base?.csF2SubcategoryName,
    csF2SubcategoryLanguage: base?.csF2SubcategoryLanguage,
    assessScore2024: null,
  };
}

/**
 * Panel to add/list/edit/delete custom attributes for a given Org × CSF2 Subcategory.
 * Props:
 * - orgID
 * - orgName
 * - csf2SubcategoryID
 * - rowsForActiveOrg (all rows for this org/subcat, baseline + customs)
 * - onUpsertRow: (row) => void   // parent merges/updates rows
 * - onDeleteRow: (rowKey) => void
 * - disabled (optional)
 */
export default function AddCustomAttributePanel({
  orgID,
  orgName,
  csf2SubcategoryID,
  rowsForActiveOrg = [],
  onUpsertRow,
  onDeleteRow,
  disabled = false,
}) {
  const toast = useToast();

  // add form
  const [ml, setMl] = React.useState(3);
  const [defn, setDefn] = React.useState('');
  const [att, setAtt] = React.useState('');

  // edit dialog
  const [editing, setEditing] = React.useState(null); // row being edited or null
  const [editDefn, setEditDefn] = React.useState('');
  const [editAtt, setEditAtt] = React.useState('');

  const customs = React.useMemo(
    () => rowsForActiveOrg.filter(r => Number(r.csF1SubcategoryID) === 0)
                          .sort((a,b) => (a.maturityLevel - b.maturityLevel) || (a.attributeNum - b.attributeNum)),
    [rowsForActiveOrg]
  );

  const resetAdd = () => { setMl(3); setDefn(''); setAtt(''); };

  async function handleAdd() {
    if (!defn.trim()) { toast.error('Please enter an attribute definition.'); return; }

    // Let backend assign number if it does; otherwise compute next
    const fallbackAttrNum = nextCustomAttrNum(rowsForActiveOrg);

    try {
      const res = await saveCustomAttribute({
        action: 'add',
        orgId: orgID,
        csf2SubcategoryId: csf2SubcategoryID,
        maturityLevel: ml,
        attributeNum: null, // let backend decide; ok to send null
        attributeDefinition: defn.trim(),
        attestation: att || null,
      });

      const assignedNum = res?.attributeNum ?? fallbackAttrNum;

      // Build row and push to parent immediately
      const base = rowsForActiveOrg[0] || null;
      const newRow = toRow({
        orgID, csF2SubcategoryID: csf2SubcategoryID,
        maturityLevel: ml, attributeNum: assignedNum,
        attributeDefinition: defn.trim(),
        attestation: att || null,
        base
      });

      onUpsertRow?.(newRow);
      toast.success('Custom attribute added');
      resetAdd();
    } catch (e) {
      toast.error('Add failed');
    }
  }

  function openEdit(r) {
    setEditing(r);
    setEditDefn(r.customAttributeDefinition || r.attributeDefinition || '');
    setEditAtt(r.selectionAttestation || '');
  }

  async function handleUpdate() {
    if (!editing) return;
    const { orgID: o, csF2SubcategoryID: s, maturityLevel: m, attributeNum: n } = editing;

    if (!editDefn.trim()) { toast.error('Please enter an attribute definition.'); return; }

    try {
      await saveCustomAttribute({
        action: 'update',
        orgId: o,
        csf2SubcategoryId: s,
        maturityLevel: m,
        attributeNum: n,
        attributeDefinition: editDefn.trim(),
        attestation: editAtt || null,
      });

      const patched = {
        ...editing,
        customAttributeDefinition: editDefn.trim(),
        selectionAttestation: editAtt || null,
      };
      onUpsertRow?.(patched);
      toast.success('Updated');
      setEditing(null);
    } catch {
      toast.error('Update failed');
    }
  }

  async function handleDelete(r) {
    try {
      await saveCustomAttribute({
        action: 'delete',
        orgId: r.orgID,
        csf2SubcategoryId: r.csF2SubcategoryID,
        maturityLevel: r.maturityLevel,
        attributeNum: r.attributeNum,
        attributeDefinition: null,
        attestation: null,
      });
      onDeleteRow?.(rowKey(r));
      toast.success('Deleted');
    } catch {
      toast.error('Delete failed');
    }
  }

  return (
    <Paper variant="outlined" sx={{ mt: 2, p: 2 }}>
      <Typography variant="h6" sx={{ mb: 1 }}>Custom Attributes — {orgName}</Typography>

      {/* Add form */}
      <Stack direction={{ xs: 'column', md: 'row' }} spacing={1.5} sx={{ mb: 2 }}>
        <Select
          size="small"
          sx={{ minWidth: 110 }}
          value={ml}
          onChange={(e) => setMl(Number(e.target.value))}
          disabled={disabled}
        >
          {ML_OPTIONS.map(v => <MenuItem key={v} value={v}>Maturity {v}</MenuItem>)}
        </Select>

        <TextField
          size="small"
          multiline
          minRows={1}
          placeholder="Attribute definition..."
          value={defn}
          onChange={(e) => setDefn(e.target.value)}
          fullWidth
          disabled={disabled}
        />

        <Select
          size="small"
          sx={{ minWidth: 200 }}
          value={att}
          displayEmpty
          onChange={(e) => setAtt(e.target.value)}
          disabled={disabled}
          renderValue={(v) => v || '2025 Attestation — optional'}
        >
          <MenuItem value=""><em>—</em></MenuItem>
          {ATTEST_OPTIONS.map(o => <MenuItem key={o} value={o}>{o}</MenuItem>)}
        </Select>

        <Button onClick={handleAdd} disabled={disabled}>Add</Button>
      </Stack>

      {/* Existing customs list */}
      {customs.length ? (
        <Box>
          <Typography variant="subtitle2" sx={{ mb: 1, color: 'text.secondary' }}>
            Existing custom attributes
          </Typography>

          <Stack spacing={1}>
            {customs.map((r) => (
              <Box
                key={rowKey(r)}
                sx={(t) => ({
                  p: 1,
                  border: '1px solid',
                  borderColor: t.palette.divider,
                  borderRadius: 1,
                  background: alpha(t.palette.info.main, r.maturityLevel === 4 ? 0.04 : 0.02),
                })}
              >
                <Stack direction="row" alignItems="flex-start" spacing={1}>
                  <Chip
                    size="small"
                    label={`ML ${r.maturityLevel}`}
                    sx={(t) => ({
                      bgcolor: r.maturityLevel === 4
                        ? alpha(t.palette.warning.main, .15)
                        : alpha(t.palette.primary.main, .15),
                    })}
                  />
                  <Typography sx={{ flex: 1, whiteSpace: 'normal', wordBreak: 'break-word' }}>
                    {r.customAttributeDefinition || r.attributeDefinition}
                  </Typography>
                  <Stack direction="row" spacing={1} alignItems="center">
                    {r.selectionAttestation ? (
                      <Chip size="small" label={r.selectionAttestation} />
                    ) : null}
                    <Tooltip title="Edit">
                      <IconButton size="small" onClick={() => openEdit(r)}>
                        <EditRoundedIcon fontSize="small" />
                      </IconButton>
                    </Tooltip>
                    <Tooltip title="Delete">
                      <IconButton size="small" onClick={() => handleDelete(r)}>
                        <DeleteOutlineRoundedIcon fontSize="small" />
                      </IconButton>
                    </Tooltip>
                  </Stack>
                </Stack>
              </Box>
            ))}
          </Stack>
        </Box>
      ) : (
        <Typography variant="body2" color="text.secondary">No custom attributes yet.</Typography>
      )}

      {/* Edit dialog */}
      <Dialog open={!!editing} onClose={() => setEditing(null)} fullWidth maxWidth="md">
        <DialogTitle>Edit custom attribute</DialogTitle>
        <DialogContent dividers>
          <Stack spacing={2}>
            <TextField
              label="Attribute definition"
              multiline minRows={3}
              value={editDefn}
              onChange={(e) => setEditDefn(e.target.value)}
              fullWidth
            />
            <Select
              size="small"
              value={editAtt}
              displayEmpty
              onChange={(e) => setEditAtt(e.target.value)}
              renderValue={(v) => v || '2025 Attestation — optional'}
            >
              <MenuItem value=""><em>—</em></MenuItem>
              {ATTEST_OPTIONS.map(o => <MenuItem key={o} value={o}>{o}</MenuItem>)}
            </Select>
          </Stack>
        </DialogContent>
        <DialogActions>
          <Button variant="text" onClick={() => setEditing(null)}>Cancel</Button>
          <Button onClick={handleUpdate}>Save</Button>
        </DialogActions>
      </Dialog>
    </Paper>
  );
}
