import * as React from 'react';
import {
  Box, Paper, Stack, Tabs, Tab, Typography, Divider
} from '@mui/material';

import AttributeFilterBar from '../components/molecules/AttributeFilterBar';
import CsfTree from '../components/organisms/CsfTree';
import SubcategoryHeader from '../components/organisms/SubcategoryHeader';

import { fetchAttributeFeed } from '../api/attributeApi';
import { normalizeHeaders, normalizeRows } from '../utils/normalizeFeed';
import { TwoPane } from '../../../ui/layout/TwoPane';
import BusyOverlay from '../../../ui/feedback/BusyOverlay';
import { useToast } from '../../../ui/feedback/useToast';

const INITIAL_FILTERS = {
  functionIds: [],
  categoryIds: [],
  subcatIds: [],
  ownerNames: [],
  custodianNames: [],
  maturity: [],
  finalOnly: false,
  search: ''
};

export default function AttributeMappingPage() {
  const { toastError } = useToast();

  const [filters, setFilters] = React.useState(INITIAL_FILTERS);
  const [loading, setLoading] = React.useState(false);

  const [headers, setHeaders] = React.useState([]); // normalized
  const [rows, setRows]       = React.useState([]); // normalized

  const [selectedSubcatId, setSelectedSubcatId] = React.useState(null);

  // Active org tab (derived from headers for selected subcat)
  const [activeOrgId, setActiveOrgId] = React.useState(null);

  // Fetch feed whenever filters change
  React.useEffect(() => {
    let ignore = false;

    (async () => {
      setLoading(true);
      try {
        const data = await fetchAttributeFeed({
          functionIds:    filters.functionIds,
          categoryIds:    filters.categoryIds,
          subcatIds:      filters.subcatIds,
          ownerNames:     filters.ownerNames,
          custodianNames: filters.custodianNames,
          maturity:       filters.maturity,
          finalOnly:      filters.finalOnly,
          search:         filters.search
        });

        if (ignore) return;

        const nh = normalizeHeaders(data.headers || []);
        const nr = normalizeRows(data.rows || []);
        setHeaders(nh);
        setRows(nr);

        // Choose a subcat if none selected or selection no longer present
        const allSubIds = Array.from(new Set(nh.map(h => String(h.csF2SubcategoryID))));
        if (!selectedSubcatId || !allSubIds.includes(String(selectedSubcatId))) {
          setSelectedSubcatId(allSubIds.length ? allSubIds[0] : null);
        }
      } catch (err) {
        if (!ignore) toastError('Failed to load data');
        // console.error(err);
      } finally {
        if (!ignore) setLoading(false);
      }
    })();

    return () => { ignore = true; };
  }, [filters, toastError]); // eslint-disable-line

  // Build org tabs for the selected subcategory
  const orgTabs = React.useMemo(() => {
    if (!selectedSubcatId) return [];
    const map = new Map();
    headers
      .filter(h => String(h.csF2SubcategoryID) === String(selectedSubcatId))
      .forEach(h => { if (!map.has(h.orgID)) map.set(h.orgID, h.orgName); });
    return Array.from(map, ([id, name]) => ({ id, name }));
  }, [headers, selectedSubcatId]);

  // Keep active org valid
  React.useEffect(() => {
    if (!orgTabs.length) {
      setActiveOrgId(null);
      return;
    }
    if (!activeOrgId || !orgTabs.some(t => String(t.id) === String(activeOrgId))) {
      setActiveOrgId(orgTabs[0].id);
    }
  }, [orgTabs, activeOrgId]);

  // Header for active org + selected subcat
  const activeHeader = React.useMemo(() => {
    if (!activeOrgId || !selectedSubcatId) return null;
    return headers.find(h =>
      String(h.orgID) === String(activeOrgId) &&
      String(h.csF2SubcategoryID) === String(selectedSubcatId)
    ) || null;
  }, [headers, activeOrgId, selectedSubcatId]);

  // Associated CSF 1.1 list for the selected subcat (distinct by name+lang)
  const associated11 = React.useMemo(() => {
    if (!selectedSubcatId) return [];
    const seen = new Set();
    const list = [];
    rows.forEach(r => {
      if (String(r.csF2SubcategoryID) !== String(selectedSubcatId)) return;
      if (!r.csF1SubcategoryID) return; // skip customs
      const key = `${r.csF1SubcategoryName}|${r.csF1SubcategoryLanguage}`;
      if (!seen.has(key)) {
        seen.add(key);
        list.push({ name: r.csF1SubcategoryName, language: r.csF1SubcategoryLanguage });
      }
    });
    return list;
  }, [rows, selectedSubcatId]);

  // Attribute rows visible for the active org + subcat
  const visibleRows = React.useMemo(() => {
    if (!activeOrgId || !selectedSubcatId) return [];
    return rows.filter(r =>
      String(r.orgID) === String(activeOrgId) &&
      String(r.csF2SubcategoryID) === String(selectedSubcatId)
    );
  }, [rows, activeOrgId, selectedSubcatId]);

  /* ================== RENDER ================== */

  const leftPane = (
    <Box sx={{ p: 0.5 }}>
      <CsfTree
        headers={headers}
        selectedSubcatID={selectedSubcatId}
        onSelectSubcat={(id) => setSelectedSubcatId(id)}
        maxHeight="calc(100vh - 260px)"
      />
    </Box>
  );

  const rightPane = (
    <Box sx={{ p: 0.5 }}>
      {/* Org tabs */}
      <Paper variant="outlined" sx={{ mb: 2, borderRadius: 2 }}>
        <Tabs
          value={activeOrgId ?? false}
          onChange={(_, v) => setActiveOrgId(v)}
          variant="scrollable"
          scrollButtons="auto"
          sx={{ px: 1 }}
        >
          {orgTabs.map(t => (
            <Tab key={t.id} value={t.id} label={t.name} />
          ))}
        </Tabs>
      </Paper>

      {/* Header – compact, side-by-side, collapsible */}
      <Box sx={{ mb: 2 }}>
        <SubcategoryHeader header={activeHeader} associated={associated11} />
      </Box>

      {/* Attributes table placeholder (next phase we’ll do the full table w/ ML color bands) */}
      <Paper variant="outlined" sx={{ borderRadius: 2 }}>
        <Box sx={{ p: 1.5 }}>
          <Typography variant="subtitle1" fontWeight={800}>
            Attributes ({visibleRows.length})
          </Typography>
        </Box>
        <Divider />
        <Box sx={{ p: 2 }}>
          {visibleRows.length === 0 ? (
            <Typography variant="body2" color="text.secondary">
              No attributes for this selection yet.
            </Typography>
          ) : (
            <Box component="table" style={{ width: '100%', borderCollapse: 'collapse' }}>
              <thead>
                <tr>
                  <th style={{ textAlign:'left', padding:'8px' }}>#</th>
                  <th style={{ textAlign:'left', padding:'8px' }}>Attribute</th>
                  <th style={{ textAlign:'left', padding:'8px' }}>ML</th>
                  <th style={{ textAlign:'left', padding:'8px' }}>NIST 1.1</th>
                  <th style={{ textAlign:'left', padding:'8px' }}>Status</th>
                  <th style={{ textAlign:'left', padding:'8px' }}>2025 Attestation</th>
                  <th style={{ textAlign:'left', padding:'8px' }}>2024 Assess</th>
                </tr>
              </thead>
              <tbody>
                {visibleRows.map((r, idx) => (
                  <tr key={`${r.ent_Subcat_Attr || 'C'}-${idx}`} style={{ borderTop:'1px solid rgba(0,0,0,.08)' }}>
                    <td style={{ padding:'8px' }}>{r.attributeNum ?? r.customAttributeNum ?? '—'}</td>
                    <td style={{ padding:'8px', whiteSpace:'pre-wrap' }}>{r.attributeDefinition || r.customAttributeDefinition || '—'}</td>
                    <td style={{ padding:'8px' }}>{r.maturityLevel ?? '—'}</td>
                    <td style={{ padding:'8px' }}>{r.csF1SubcategoryName || '—'}</td>
                    <td style={{ padding:'8px' }}>{r.selectionStatus || '—'}</td>
                    <td style={{ padding:'8px' }}>{r.selectionAttestation || r.customAttributeAttestation || '—'}</td>
                    <td style={{ padding:'8px' }}>{r.assessScore2024 ?? '—'}</td>
                  </tr>
                ))}
              </tbody>
            </Box>
          )}
        </Box>
      </Paper>
    </Box>
  );

  return (
    <Box sx={{ px: { xs: 1, md: 2 }, py: 2 }}>
      {/* Reusable filter bar (spacious) */}
      <Box sx={{ mb: 2 }}>
        <AttributeFilterBar
          value={filters}
          onChange={setFilters}
          onExport={() => {/* wire export later */}}
        />
      </Box>

      <TwoPane
        left={leftPane}
        right={rightPane}
        leftWidth={{ xs: '100%', lg: 430 }}
        gap={2}
      />

      <BusyOverlay open={loading} label="Loading…" />
    </Box>
  );
}
