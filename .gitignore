// src/features/attributeMapping/components/molecules/AddCustomAttributePanel.jsx
import * as React from 'react';
import {
  Box, Paper, Stack, Select, MenuItem, TextField, Button, Chip,
  IconButton, Tooltip, Divider, Typography
} from '@mui/material';
import EditOutlinedIcon from '@mui/icons-material/EditOutlined';
import DeleteOutlineOutlinedIcon from '@mui/icons-material/DeleteOutlineOutlined';
import SaveOutlinedIcon from '@mui/icons-material/SaveOutlined';
import CloseOutlinedIcon from '@mui/icons-material/CloseOutlined';
import { saveCustomAttribute } from '../../api/customApi';
import useToast from '../../../../ui/feedback/useToast';

const ATTEST_OPTIONS = ['Meet', 'Partially Meet', 'Does Not Meet'];

/**
 * Props:
 *  orgID, orgName
 *  csF2SubcategoryID (canonical)  // NOTE: prefer this one
 *  csf2SubcategoryID (legacy alias; tolerated)
 *  subcatName
 *  existingRows: all rows (baseline+custom) for this org/subcat
 *  onAdded(newRow), onPatched(key, patch), onDeleted(key)
 */
export default function AddCustomAttributePanel({
  orgID,
  orgName,
  csF2SubcategoryID,
  csf2SubcategoryID,   // legacy alias
  subcatName,
  existingRows = [],
  onAdded,
  onPatched,
  onDeleted,
}) {
  const subcatId = csF2SubcategoryID ?? csf2SubcategoryID;
  const { success, error } = useToast();

  // ---------- derive current custom items from parent rows ----------
  const seedList = React.useMemo(
    () =>
      (existingRows || []).filter(
        r =>
          (r.isCustom || r.customAttributeDefinition) &&
          String(r.orgID) === String(orgID) &&
          String(r.csF2SubcategoryID) === String(subcatId)
      ),
    [existingRows, orgID, subcatId]
  );
  const [items, setItems] = React.useState(seedList);
  React.useEffect(() => setItems(seedList), [seedList]);

  // ---------- add form ----------
  const [ml, setMl]   = React.useState(3);
  const [def, setDef] = React.useState('');
  const [att, setAtt] = React.useState('');
  const [adding, setAdding] = React.useState(false);

  /** Canonical key for CUSTOM rows: org|sub|ml|C|0|customNum (matches table/page) */
  const makeKey = React.useCallback((r) => {
    const org = String(r.orgID ?? '0');
    const sub = String(r.csF2SubcategoryID ?? '0');
    const ml  = String(r.maturityLevel ?? '0');
    const num = String(r.customAttributeNum ?? '0');
    return `${org}|${sub}|${ml}|C|0|${num}`;
  }, []);

  // next custom # per ML (client-side fallback if API doesn’t echo one back)
  const nextNum = React.useCallback((m) => {
    const nums = items
      .filter(x => Number(x.maturityLevel) === Number(m))
      .map(x => Number(x.customAttributeNum || 0));
    return (nums.length ? Math.max(...nums) : 0) + 1;
  }, [items]);

  // local mutations to keep panel responsive before parent diff arrives
  const addItemLocal = React.useCallback((row) => {
    setItems(prev => {
      const list = [...prev, row];
      // ML3 → ML4, then by custom num
      return list.sort((a, b) => {
        const ar = Number(a.maturityLevel) === 4 ? 2 : 1;
        const br = Number(b.maturityLevel) === 4 ? 2 : 1;
        if (ar !== br) return ar - br;
        return (a.customAttributeNum ?? 0) - (b.customAttributeNum ?? 0);
      });
    });
  }, []);

  const patchLocal = React.useCallback((key, patch) => {
    setItems(prev => prev.map(x => (makeKey(x) === key ? { ...x, ...patch } : x)));
  }, [makeKey]);

  const deleteLocal = React.useCallback((key) => {
    setItems(prev => prev.filter(x => makeKey(x) !== key));
  }, [makeKey]);

  const handleAdd = async () => {
    if (!def.trim()) return;
    setAdding(true);

    const localNum = nextNum(ml);
    try {
      const resp = await saveCustomAttribute({
        action: 'Add',
        orgId: orgID,
        csf2SubcategoryId: subcatId,
        maturityLevel: ml,
        attributeNum: localNum,        // fallback number if API doesn’t echo
        attrDefinition: def.trim(),    // server expects attrDefinition
        attestation: att || null,
      });

      const serverNum = resp?.customAttributeNum ?? resp?.attributeNum ?? localNum;
      const serverDef = resp?.customAttributeDefinition ?? resp?.attrDefinition ?? def.trim();
      const serverAtt = resp?.attestation ?? (att || null);

      const newRow = {
        isCustom: true,
        orgID,
        csF2SubcategoryID: subcatId,
        maturityLevel: ml,
        customAttributeNum: serverNum,
        customAttributeDefinition: serverDef,
        customAttributeAttestation: serverAtt,
        attributeNum: null, // not baseline
      };

      // immediate local + bubble up
      addItemLocal(newRow);
      onAdded?.(newRow);

      success('Custom attribute added');
      setDef('');
      setAtt('');
    } catch {
      error('Add failed');
    } finally {
      setAdding(false);
    }
  };

  // ---------- item row (inline edit/delete) ----------
  const RowItem = ({ row }) => {
    const [edit, setEdit] = React.useState(false);
    const [edef, setEdef] = React.useState(row.customAttributeDefinition || '');
    const [eatt, setEatt] = React.useState(row.customAttributeAttestation || '');
    const [saving, setSaving] = React.useState(false);

    React.useEffect(() => {
      if (!edit) {
        setEdef(row.customAttributeDefinition || '');
        setEatt(row.customAttributeAttestation || '');
      }
    }, [edit, row.customAttributeDefinition, row.customAttributeAttestation]);

    const key = makeKey(row);

    const save = async () => {
      if (!edef.trim()) return;
      setSaving(true);
      try {
        await saveCustomAttribute({
          action: 'Update', // keep casing you’re using here
          orgId: row.orgID,
          csf2SubcategoryId: row.csF2SubcategoryID,
          maturityLevel: row.maturityLevel,
          attributeNum: row.customAttributeNum,
          attrDefinition: edef.trim(),
          attestation: eatt || null,
        });
        const patch = {
          customAttributeDefinition: edef.trim(),
          customAttributeAttestation: eatt || null,
        };
        patchLocal(key, patch);     // instant in-panel
        onPatched?.(key, patch);    // update parent/table
        success('Updated');
        setEdit(false);
      } catch {
        error('Update failed');
      } finally {
        setSaving(false);
      }
    };

    const remove = async () => {
      try {
        await saveCustomAttribute({
          action: 'Delete',
          orgId: row.orgID,
          csf2SubcategoryId: row.csF2SubcategoryID,
          maturityLevel: row.maturityLevel,
          attributeNum: row.customAttributeNum,
        });
        deleteLocal(key);        // instant in-panel
        onDeleted?.(key);        // remove from parent/table
        success('Deleted');
      } catch {
        error('Delete failed');
      }
    };

    return (
      <Paper variant="outlined" sx={{ p: 1 }}>
        <Stack direction="row" spacing={1} alignItems="center">
          <Chip size="small" label={`ML ${row.maturityLevel}`} />

          {edit ? (
            <>
              <TextField
                size="small"
                fullWidth
                value={edef}
                onChange={(e) => setEdef(e.target.value)}
              />
              <Select
                size="small"
                displayEmpty
                value={eatt || ''}
                onChange={(e) => setEatt(e.target.value || '')}
                renderValue={(v) => (v ? v : '2025 Attestation')}
                sx={{ minWidth: 220 }}
              >
                <MenuItem value=""><em>—</em></MenuItem>
                {ATTEST_OPTIONS.map(o => <MenuItem key={o} value={o}>{o}</MenuItem>)}
              </Select>
              <Tooltip title="Save">
                <span>
                  <IconButton size="small" onClick={save} disabled={saving || !edef.trim()}>
                    <SaveOutlinedIcon fontSize="small" />
                  </IconButton>
                </span>
              </Tooltip>
              <Tooltip title="Cancel">
                <IconButton
                  size="small"
                  onClick={() => {
                    setEdit(false);
                    setEdef(row.customAttributeDefinition || '');
                    setEatt(row.customAttributeAttestation || '');
                  }}
                >
                  <CloseOutlinedIcon fontSize="small" />
                </IconButton>
              </Tooltip>
            </>
          ) : (
            <>
              <Typography variant="body2" sx={{ flex: 1 }}>{row.customAttributeDefinition}</Typography>

              {row.customAttributeAttestation ? (
                <Chip
                  size="small"
                  label={row.customAttributeAttestation}
                  sx={(t) => ({
                    bgcolor:
                      row.customAttributeAttestation === 'Meet' ? t.palette.success.main :
                      row.customAttributeAttestation === 'Partially Meet' ? t.palette.warning.main :
                      t.palette.error.main,
                    color: row.customAttributeAttestation === 'Partially Meet'
                      ? t.palette.common.black
                      : t.palette.common.white,
                    fontWeight: 600
                  })}
                />
              ) : (
                <Typography variant="body2" color="text.secondary">—</Typography>
              )}

              <Tooltip title="Edit">
                <IconButton size="small" onClick={() => setEdit(true)}>
                  <EditOutlinedIcon fontSize="small" />
                </IconButton>
              </Tooltip>
              <Tooltip title="Delete">
                <IconButton size="small" onClick={remove}>
                  <DeleteOutlineOutlinedIcon fontSize="small" />
                </IconButton>
              </Tooltip>
            </>
          )}
        </Stack>
      </Paper>
    );
  };

  // ---------- UI ----------
  return (
    <Paper variant="outlined" sx={{ mt: 2, p: 1.5 }}>
      <Stack direction={{ xs: 'column', md: 'row' }} justifyContent="space-between" sx={{ mb: 1 }}>
        <Typography variant="subtitle2">
          Custom Attributes — {orgName || 'Org'} / {subcatName}
        </Typography>
      </Stack>

      {/* Add row */}
      <Stack
        direction={{ xs: 'column', md: 'row' }}
        spacing={1}
        alignItems={{ md: 'center' }}
        sx={{ mb: 1.25 }}
      >
        <Select
          size="small"
          value={ml}
          onChange={(e) => setMl(Number(e.target.value))}
          sx={{ width: 180 }}
          renderValue={(v) => (v === 4 ? 'Maturity Level 4' : 'Maturity Level 3')}
        >
          <MenuItem value={3}>Maturity Level 3</MenuItem>
          <MenuItem value={4}>Maturity Level 4</MenuItem>
        </Select>

        <TextField
          size="small"
          fullWidth
          placeholder="Attribute definition…"
          value={def}
          onChange={(e) => setDef(e.target.value)}
        />

        <Select
          size="small"
          displayEmpty
          value={att || ''}
          onChange={(e) => setAtt(e.target.value || '')}
          renderValue={(v) => (v ? v : '2025 Attestation')}
          sx={{ width: { xs: '100%', md: 220 } }}
        >
          <MenuItem value=""><em>—</em></MenuItem>
          {ATTEST_OPTIONS.map(o => <MenuItem key={o} value={o}>{o}</MenuItem>)}
        </Select>

        <Button
          variant="contained"
          onClick={handleAdd}
          disabled={adding || !def.trim()}
          sx={{ minWidth: 88 }}
        >
          {adding ? 'Adding…' : 'Add'}
        </Button>
      </Stack>

      <Divider sx={{ my: 1 }} />

      {/* Grouped display */}
      <GroupBlock
        title="Maturity Level 3"
        items={items.filter(x => Number(x.maturityLevel) === 3)}
        RowItem={RowItem}
      />
      <Box sx={{ height: 8 }} />
      <GroupBlock
        title="Maturity Level 4"
        items={items.filter(x => Number(x.maturityLevel) === 4)}
        RowItem={RowItem}
      />
    </Paper>
  );
}

function GroupBlock({ title, items, RowItem }) {
  return (
    <Box>
      <Typography variant="overline" sx={{ color: 'text.secondary' }}>{title}</Typography>
      <Stack spacing={0.75} sx={{ mt: 0.5 }}>
        {items.length === 0 ? (
          <Typography variant="body2" color="text.secondary">No custom attributes.</Typography>
        ) : (
          items.map(r => (
            <RowItem key={`ml${r.maturityLevel}-c${r.customAttributeNum}`} row={r} />
          ))
        )}
      </Stack>
    </Box>
  );
}
