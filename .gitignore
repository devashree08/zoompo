import { createWorkbook, autoFitColumns } from '../../../ui/data/xlsx/excel';

// ===== Styling helpers =====
const solid = (argb) => ({ type: 'pattern', pattern: 'solid', fgColor: { argb } });
const WHITE_BOLD = { color: { argb: 'FFFFFFFF' }, bold: true };
const BOLD = { bold: true };
const BORDER_THIN = {
  top:    { style: 'thin', color: { argb: 'FFCBD5E1' } },
  left:   { style: 'thin', color: { argb: 'FFCBD5E1' } },
  bottom: { style: 'thin', color: { argb: 'FFCBD5E1' } },
  right:  { style: 'thin', color: { argb: 'FFCBD5E1' } },
};

// Global header band color
const HDR_BAND = 'FF2F3A4A';

// Attestation deep colors (for value cells)
function colorAttestation(cell, v) {
  if (v === 'Meet') {
    cell.fill = solid('FF12B76A');
    cell.font = WHITE_BOLD;
  } else if (v === 'Partial Meet' || v === 'Partially Meet') {
    cell.fill = solid('FFF79009');
    cell.font = { bold: true };
  } else if (v === 'Does Not Meet') {
    cell.fill = solid('FFD92D20');
    cell.font = WHITE_BOLD;
  }
}

// Excel-safe sheet names
function safeSheetName(name) {
  const cleaned = (name || 'Org')
    .replace(/[\[\]\:\*\?\/\\]/g, ' ')
    .slice(0, 31)
    .trim();
  return cleaned || 'Org';
}

// UI-sort for detail rows: CSF2 → CSF1 (custom last) → baseline before custom → ML (3→4) → Attr#
function sortRowsLikeTable(a, b) {
  if (a.csF2SubcategoryID !== b.csF2SubcategoryID)
    return a.csF2SubcategoryID - b.csF2SubcategoryID;

  const aKey = a.csF1SubcategoryID || 999999; // 0/custom last
  const bKey = b.csF1SubcategoryID || 999999;
  if (aKey !== bKey) return aKey - bKey;

  const aIsCustom = !!a.customAttributeDefinition;
  const bIsCustom = !!b.customAttributeDefinition;
  if (aIsCustom !== bIsCustom) return aIsCustom ? 1 : -1;

  if (a.maturityLevel !== b.maturityLevel) return a.maturityLevel - b.maturityLevel;

  const aNum = a.attributeNum || a.customAttributeNum || 999999;
  const bNum = b.attributeNum || b.customAttributeNum || 999999;
  return aNum - bNum;
}

// Attributes table columns (detail section)
function getDetailColumns() {
  return [
    { header: 'Function',                key: 'functionName'              },
    { header: 'Function Language',       key: 'functionLanguage'          },
    { header: 'Category',                key: 'categoryName'              },
    { header: 'Category Language',       key: 'categoryLanguage'          },
    { header: 'CSF 2.0 Subcategory',     key: 'csf2Name'                  },
    { header: 'Subcategory Language',    key: 'csf2Lang'                  },
    { header: 'Change Summary',          key: 'changeSummary'             },
    { header: 'Implementation Examples', key: 'implementationExamples'    },

    { header: 'Associated NIST 1.1',     key: 'csf1Name'                  },
    { header: 'Type',                    key: 'type'                      }, // Baseline | Custom

    { header: 'ML',                      key: 'ml'                        }, // numeric only
    { header: 'Attr #',                  key: 'attrNum'                   },
    { header: 'Attribute Definition',    key: 'attrDef'                   },

    { header: 'Status',                  key: 'status'                    }, // editable in portal
    { header: '2025 Attestation',        key: 'attestation'               }, // editable in portal
    { header: '2024 Assessor Score',     key: 'assess2024'                },

    { header: 'Owner(s)',                key: 'owner'                     },
    { header: 'Custodian(s)',            key: 'custodian'                 },
  ];
}

// Put thin border around every cell in a row (for the used columns)
function borderRow(row, usedCols) {
  for (let c = 1; c <= usedCols; c++) {
    row.getCell(c).border = BORDER_THIN;
  }
}

// Write a small per-org summary section (by subcategory)
function writeSummarySection(ws, summaryRows) {
  let r = 1;

  const title = ws.getCell(r, 1);
  title.value = 'Summary by CSF 2.0 Subcategory';
  title.font = { bold: true, size: 12 };
  r += 1;

  // Header
  const hdr = ws.getRow(r);
  const hdrVals = [
    'Function', 'Category', 'CSF 2.0 Subcategory',
    'Kept', 'Removed', 'Custom',
  ];
  hdrVals.forEach((text, i) => {
    const cell = ws.getCell(r, i + 1);
    cell.value = text;
    cell.font = { bold: true, color: { argb: 'FFFFFFFF' } };
    cell.alignment = { vertical: 'middle', horizontal: 'center', wrapText: true };
    cell.fill = solid(HDR_BAND);
    cell.border = BORDER_THIN;
  });
  r += 1;

  // Rows
  summaryRows.forEach(sr => {
    const row = ws.getRow(r);
    row.getCell(1).value = sr.functionName;
    row.getCell(2).value = sr.categoryName;
    row.getCell(3).value = sr.csf2Name;
    row.getCell(4).value = sr.keptCount || 0;
    row.getCell(5).value = sr.removedCount || 0;
    row.getCell(6).value = sr.customCount || 0;
    borderRow(row, 6);
    r += 1;
  });

  // spacer
  r += 1;
  return r; // next free row index
}

/**
 * Build workbook:
 * - one sheet per org (for ALL orgs provided), even if no data
 * - each sheet: Summary section + Attributes table
 * - attributes header row is frozen (sticky)
 * - custom attribute definitions tinted; all cells bordered
 *
 * @param {Object} params
 * @param {Array}  params.headers   feed headers (used for summary and context)
 * @param {Array}  params.rows      feed rows (all subcategories, all orgs)
 * @param {Array}  params.orgs      [{orgID, orgName}] for ALL orgs to ensure a sheet per org
 */
export async function buildAttributeWorkbook({ headers = [], rows = [], orgs = [] }) {
  const wb = createWorkbook();

  // Index headers for summary lookups and row context
  const headersByOrgSub = new Map(); // key: `${orgID}|${csf2Id}` → header
  headers.forEach(h => {
    headersByOrgSub.set(`${h.orgID}|${h.csF2SubcategoryID}`, h);
  });

  // Group detail rows by org
  const rowsByOrg = new Map();
  rows.forEach(r => {
    const k = r.orgID;
    if (!rowsByOrg.has(k)) rowsByOrg.set(k, []);
    rowsByOrg.get(k).push(r);
  });

  // Precompute per-org summary rows from headers
  const summaryByOrg = new Map();
  headers.forEach(h => {
    const list = summaryByOrg.get(h.orgID) || [];
    list.push({
      functionName: h.functionName,
      categoryName: h.categoryName,
      csf2Name:     h.csF2SubcategoryName,
      keptCount:    h.keptCount,
      removedCount: h.removedCount,
      customCount:  h.customCount,
    });
    summaryByOrg.set(h.orgID, list);
  });

  // Ensure we create a sheet for every org in `orgs`
  const uniqueOrgs = (orgs && orgs.length)
    ? orgs
    : Array.from(new Map(headers.map(h => [h.orgID, { orgID: h.orgID, orgName: h.orgName }])).values());

  for (const org of uniqueOrgs) {
    const ws = wb.addWorksheet(safeSheetName(org.orgName));

    // 1) SUMMARY SECTION (top)
    const summaryRows = summaryByOrg.get(org.orgID) || [];
    const nextRowStart = writeSummarySection(ws, summaryRows);

    // 2) ATTRIBUTES TABLE (below)
    ws.columns = getDetailColumns();

    // Write header at row = nextRowStart
    const hdrRow = ws.getRow(nextRowStart);
    ws.columns.forEach((col, i) => {
      const cell = hdrRow.getCell(i + 1);
      cell.value = col.header;
      cell.font = { bold: true, color: { argb: 'FFFFFFFF' } };
      cell.alignment = { vertical: 'middle', horizontal: 'center', wrapText: true };
      cell.fill = solid(HDR_BAND);
      cell.border = BORDER_THIN;
    });

    // Freeze pane just below attributes header
    ws.views = [{ state: 'frozen', ySplit: nextRowStart }];

    const detailRows = (rowsByOrg.get(org.orgID) || []).slice().sort(sortRowsLikeTable);

    if (!detailRows.length) {
      const r = ws.getRow(nextRowStart + 1);
      r.getCell(1).value = 'No attribute rows under current filters.';
      r.getCell(1).font = { italic: true, color: { argb: 'FF667085' } };
      // give a border to first few cells so it doesn’t look odd
      borderRow(r, Math.min(6, ws.columns.length));
    } else {
      detailRows.forEach(r => {
        const isCustom = !!r.customAttributeDefinition;
        const ctx = headersByOrgSub.get(`${r.orgID}|${r.csF2SubcategoryID}`) || r;

        const attrDef = r.attributeDefinition || r.customAttributeDefinition || '';
        const attrNum = r.attributeNum || r.customAttributeNum || '';
        const att     = r.selectionAttestation || r.customAttributeAttestation || '';
        const status  = isCustom ? '' : (r.selectionStatus || '');
        const type    = isCustom ? 'Custom' : 'Baseline';

        const row = ws.addRow({
          functionName:             r.functionName,
          functionLanguage:         r.functionLanguage,
          categoryName:             r.categoryName,
          categoryLanguage:         r.categoryLanguage,
          csf2Name:                 r.csF2SubcategoryName,
          csf2Lang:                 r.csF2SubcategoryLanguage,
          changeSummary:            ctx.changeSummary || r.changeSummary,
          implementationExamples:   ctx.implementationExamples || r.implementationExamples,

          csf1Name:                 r.csF1SubcategoryName || '',
          type:                     type,

          ml:                       r.maturityLevel, // numeric only (no “(Custom)”)
          attrNum:                  attrNum,
          attrDef:                  attrDef,

          status:                   status,
          attestation:              att,
          assess2024:               r.assessScore2024 || '',

          owner:                    r.owner || '',
          custodian:                r.custodian || '',
        });

        // Borders on all cells
        borderRow(row, ws.columns.length);

        // Wrap long text
        row.getCell('changeSummary').alignment = { wrapText: true };
        row.getCell('implementationExamples').alignment = { wrapText: true };
        row.getCell('attrDef').alignment = { wrapText: true };
        row.getCell('ml').alignment = { horizontal: 'center' };

        // Attestation deep color
        colorAttestation(row.getCell('attestation'), att);

        // **Custom attribute**: tint definition cell + keep borders
        if (isCustom) {
          // change color as requested (distinct) and keep thin border
          row.getCell('attrDef').fill = solid('FFE6F4FF'); // light blue tint
        }

        // Status colors (baseline rows)
        const stCell = row.getCell('status');
        if (stCell.value === 'Keep') {
          stCell.fill = solid('FFECFDF3'); // light green
          stCell.font = { color: { argb: 'FF027A48' }, bold: true };
        } else if (stCell.value === 'Remove') {
          stCell.fill = solid('FFFEF3F2'); // light red
          stCell.font = { color: { argb: 'FF912018' }, bold: true };
        }
      });
    }

    autoFitColumns(ws, { min: 8, max: 100 });
  }

  return wb;
}
