// src/features/attributeMapping/pages/AttributeMappingPage.js
import * as React from 'react';
import { Box, Typography, Stack, Button } from '@mui/material';

import AttributeFilterBar from '../components/molecules/AttributeFilterBar';
import TwoPane from '../../../ui/layout/TwoPane';
import BusyOverlay from '../../../ui/feedback/BusyOverlay';

import CsfTree from '../components/organisms/CsfTree';
import RightHeaderComposite from '../components/organisms/RightHeaderComposite';
import OrgTabs from '../components/molecules/OrgTabs';
import AttributeGroupTable from '../components/organisms/AttributeGroupTable';
import AddCustomAttributePanel from '../components/molecules/AddCustomAttributePanel';

import { fetchAttributeFeed } from '../api/attributeApi';
import { exportRowsAsCsv } from '../../../ui/data/csvExport';
import { normalizeHeaders, normalizeRows } from '../utils/normalizeFeed';

// Filters (no Org filter by design)
const initialFilters = {
  functionIds: [],
  categoryIds: [],
  subcatIds: [],
  ownerNames: [],
  custodianNames: [],
  maturity: [],
  finalOnly: false,
  search: ''
};

export default function AttributeMappingPage() {
  // filters & data
  const [filters, setFilters] = React.useState(initialFilters);
  const [headers, setHeaders] = React.useState([]);
  const [rows, setRows] = React.useState([]);

  // selection state
  const [selectedSubcatID, setSelectedSubcatID] = React.useState(null);
  const [activeOrgID, setActiveOrgID] = React.useState(null);

  // loading flags
  const [initialLoading, setInitialLoading] = React.useState(true);
  const [loadingHeaders, setLoadingHeaders] = React.useState(false);
  const [loadingRows, setLoadingRows] = React.useState(false);

  const mode = selectedSubcatID ? 'detail' : 'browse';

  // ------- loaders -------
  const loadHeaders = React.useCallback(async () => {
    setLoadingHeaders(true);
    try {
      const resp = await fetchAttributeFeed({
        functionIds:  filters.functionIds,
        categoryIds:  filters.categoryIds,
        subcatIds:    filters.subcatIds,
        ownerNames:   filters.ownerNames,
        custodianNames: filters.custodianNames,
        maturity:     filters.maturity,
        finalOnly:    filters.finalOnly,
        search:       filters.search
      });
      setHeaders(normalizeHeaders(resp.headers || []));
    } finally {
      setLoadingHeaders(false);
      if (initialLoading) setInitialLoading(false);
    }
  }, [filters, initialLoading]);

  const loadRowsForSubcat = React.useCallback(async (subcatID) => {
    if (!subcatID) { setRows([]); return; }
    setLoadingRows(true);
    try {
      const resp = await fetchAttributeFeed({
        functionIds:  filters.functionIds,
        categoryIds:  filters.categoryIds,
        subcatIds:    [subcatID],   // rows only for the selected subcategory
        ownerNames:   filters.ownerNames,
        custodianNames: filters.custodianNames,
        maturity:     filters.maturity,
        finalOnly:    filters.finalOnly,
        search:       filters.search
      });
      setRows(normalizeRows(resp.rows || []));
    } finally {
      setLoadingRows(false);
    }
  }, [filters]);

  // refresh headers on filter change
  React.useEffect(() => { loadHeaders(); }, [
    filters.functionIds, filters.categoryIds, filters.subcatIds,
    filters.ownerNames, filters.custodianNames, filters.maturity,
    filters.finalOnly, filters.search, loadHeaders
  ]);

  // refresh rows when subcategory changes
  React.useEffect(() => { loadRowsForSubcat(selectedSubcatID); }, [selectedSubcatID, loadRowsForSubcat]);

  // ------- derived for detail pane -------
  const orgsForTabs = React.useMemo(() => {
    if (!selectedSubcatID) return [];
    const m = new Map();
    headers
      .filter(h => h.csF2SubcategoryID === selectedSubcatID)
      .forEach(h => m.set(h.orgID, { orgID: h.orgID, orgName: h.orgName }));
    return Array.from(m.values()).sort((a,b) => a.orgID - b.orgID);
  }, [headers, selectedSubcatID]);

  React.useEffect(() => {
    if (!orgsForTabs.length) { setActiveOrgID(null); return; }
    if (!activeOrgID || !orgsForTabs.some(o => o.orgID === activeOrgID)) {
      setActiveOrgID(orgsForTabs[0].orgID);
    }
  }, [orgsForTabs, activeOrgID]);

  const selectedHeader = React.useMemo(() => {
    if (!selectedSubcatID) return null;
    return (
      headers.find(h => h.csF2SubcategoryID === selectedSubcatID && h.orgID === activeOrgID) ||
      headers.find(h => h.csF2SubcategoryID === selectedSubcatID) || null
    );
  }, [headers, selectedSubcatID, activeOrgID]);

  const rowsForSelected = React.useMemo(
    () => rows.filter(r => r.csF2SubcategoryID === selectedSubcatID),
    [rows, selectedSubcatID]
  );
  const rowsForActiveOrg = React.useMemo(
    () => rowsForSelected.filter(r => r.orgID === activeOrgID),
    [rowsForSelected, activeOrgID]
  );

  const ownerCsv = React.useMemo(() => {
    const h = headers.find(x => x.csF2SubcategoryID === selectedSubcatID && x.orgID === activeOrgID);
    return h?.owner || '';
  }, [headers, selectedSubcatID, activeOrgID]);

  const custodianCsv = React.useMemo(() => {
    const h = headers.find(x => x.csF2SubcategoryID === selectedSubcatID && x.orgID === activeOrgID);
    return h?.custodian || '';
  }, [headers, selectedSubcatID, activeOrgID]);

  // ------- handlers -------
  const handleSelectSubcat = (id) => setSelectedSubcatID(id);
  const handleBack = () => setSelectedSubcatID(null);
  const handleExport = () => rows?.length && exportRowsAsCsv(rows, 'csf-attribute-rows.csv');

  // ------- render -------
  return (
    <Box sx={{ px: { xs: 1, md: 2 }, pb: 3 }}>
      <AttributeFilterBar value={filters} onChange={setFilters} onExport={handleExport} />

      {/* extra breathing room below filters */}
      <Box sx={{ mt: 3 }}>
        {mode === 'browse' ? (
          <>
            <Typography variant="subtitle2" color="text.secondary" sx={{ mb: 1 }}>
              CSF 2.0 Structure
            </Typography>
            <CsfTree headers={headers} onSelectSubcat={handleSelectSubcat} selectedSubcatID={null} />
            {loadingHeaders && (
              <Typography variant="caption" color="text.secondary" sx={{ mt: 1, display:'block' }}>
                Loading…
              </Typography>
            )}
          </>
        ) : (
          <TwoPane
            left={
              <>
                <Stack direction="row" alignItems="center" spacing={1} sx={{ mb: 1 }}>
                  <Button size="small" onClick={handleBack}>← Back</Button>
                  <Typography variant="subtitle2" color="text.secondary">CSF 2.0 Structure</Typography>
                </Stack>
                <CsfTree
                  headers={headers}
                  onSelectSubcat={handleSelectSubcat}
                  selectedSubcatID={selectedSubcatID}
                  maxHeight="calc(100vh - 210px)"
                />
              </>
            }
            right={
              !selectedHeader ? (
                <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
                  {loadingRows ? 'Loading…' : 'Select a subcategory from the left to view details.'}
                </Typography>
              ) : (
                <>
                  {/* Non-sticky, collapsible header with “Show more / open in new window” dialogs */}
                  <RightHeaderComposite
                    header={selectedHeader}
                    associatedRows={rowsForSelected}
                    ownerCsv={ownerCsv}
                    custodianCsv={custodianCsv}
                  />

                  {/* Org tabs + attributes (read-only for now) */}
                  <OrgTabs
                    orgs={orgsForTabs}
                    activeOrgID={activeOrgID}
                    editableOrgID={activeOrgID}
                    onChange={setActiveOrgID}
                  />

                  <AttributeGroupTable rows={rowsForActiveOrg} />

                  {/* Placeholder for future create (still inside right-pane scroll) */}
                  <AddCustomAttributePanel
                    orgName={orgsForTabs.find(x => x.orgID === activeOrgID)?.orgName}
                    subcatName={selectedHeader.csF2SubcategoryName}
                    editable={false}
                  />
                </>
              )
            }
          />
        )}
      </Box>

      {/* initial mount only */}
      <BusyOverlay open={initialLoading} />
    </Box>
  );
}
