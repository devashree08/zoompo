import * as React from 'react';
import {
  Paper, Box, Stack, Typography, Select, MenuItem, TextField, Button,
  IconButton, Chip, Divider, Dialog, DialogTitle, DialogContent, DialogActions,
  Tooltip
} from '@mui/material';
import EditRoundedIcon from '@mui/icons-material/EditRounded';
import DeleteRoundedIcon from '@mui/icons-material/DeleteRounded';

import { saveCustom } from '../../api/customApi';
import useToast from '../../../../ui/feedback/useToast';

const ATTEST_OPTIONS = ['Meet', 'Partial Meet', 'Does Not Meet'];

export default function AddCustomAttributePanel({
  orgID,
  orgName,
  csf2SubcategoryID,
  subcatName,
  existingRows = [],        // full rows for this org + subcat (baseline + custom)
  onAdded,                  // (newRow) => void   -> append to table
  onPatched,                // (key, patch) => void
  onDeleted,                // (key) => void
}) {
  const { success, error } = useToast();

  // ---------- compose next attributeNum (never null) ----------
  const nextAttrNum = React.useMemo(() => {
    // look only at custom rows for this org + subcat
    const candidates = existingRows
      .filter(r => (r.orgID === orgID) && (r.csF2SubcategoryID === csf2SubcategoryID) &&
                   (r.isCustom || r.customAttributeDefinition || r.customAttributeNum != null))
      .map(r => Number(r.customAttributeNum ?? r.attributeNum ?? 0));
    const max = candidates.length ? Math.max(...candidates) : 0;
    return max + 1;
  }, [existingRows, orgID, csf2SubcategoryID]);

  // ---------- add form ----------
  const [ml, setMl] = React.useState(3);
  const [def, setDef] = React.useState('');
  const [att, setAtt] = React.useState('');

  const canAdd = def.trim().length > 0 && (ml === 3 || ml === 4);

  const handleAdd = async () => {
    if (!canAdd) return;
    const payload = {
      action: 'add',
      orgId: orgID,
      csf2SubcategoryId: csf2SubcategoryID,
      maturityLevel: ml,
      attributeNum: nextAttrNum,
      attrDefinition: def.trim(),      // <-- as you requested
      attestation: att || null,
    };

    try {
      const saved = await saveCustom(payload);

      // construct a table row that matches AttributeGroupTable
      const newRow = {
        orgID,
        csF2SubcategoryID: csf2SubcategoryID,
        csF1SubcategoryID: null,
        csF1SubcategoryName: '',

        maturityLevel: ml,
        attributeNum: nextAttrNum,      // keeps key uniqueness

        // show in “Attribute Definition”
        attributeDefinition: def.trim(),

        // no Status for custom
        selectionStatus: null,

        // 2025 Attestation column shows custom’s attestation as a chip
        customAttributeAttestation: att || null,

        // 2024 Assessor Score blank
        assessScore2024: null,

        // flags to make the table treat this as custom
        isCustom: true,
        customAttributeNum: nextAttrNum,
        customAttributeDefinition: def.trim(),
      };

      onAdded?.(newRow);
      success('Custom attribute added');
      // reset form
      setDef('');
      setAtt('');
    } catch (e) {
      error('Failed to add custom attribute');
    }
  };

  // ---------- edit dialog ----------
  const [editOpen, setEditOpen] = React.useState(false);
  const [editRow, setEditRow]   = React.useState(null);
  const [editDef, setEditDef]   = React.useState('');
  const [editAtt, setEditAtt]   = React.useState('');

  const startEdit = (row) => {
    setEditRow(row);
    setEditDef(row.customAttributeDefinition || row.attributeDefinition || '');
    setEditAtt(row.customAttributeAttestation || '');
    setEditOpen(true);
  };

  const saveEdit = async () => {
    if (!editRow) return;
    try {
      await saveCustom({
        action: 'update',
        orgId: editRow.orgID,
        csf2SubcategoryId: editRow.csF2SubcategoryID,
        maturityLevel: editRow.maturityLevel,
        attributeNum: editRow.customAttributeNum ?? editRow.attributeNum,
        attrDefinition: editDef.trim(),
        attestation: editAtt || null,
      });

      onPatched?.(
        `${editRow.orgID}|${editRow.csF2SubcategoryID}|${editRow.maturityLevel}|${editRow.attributeNum}`,
        {
          attributeDefinition: editDef.trim(),
          customAttributeDefinition: editDef.trim(),
          customAttributeAttestation: editAtt || null,
        }
      );
      setEditOpen(false);
      success('Custom attribute updated');
    } catch {
      error('Failed to update');
    }
  };

  const remove = async (row) => {
    try {
      await saveCustom({
        action: 'delete',
        orgId: row.orgID,
        csf2SubcategoryId: row.csF2SubcategoryID,
        maturityLevel: row.maturityLevel,
        attributeNum: row.customAttributeNum ?? row.attributeNum,
      });
      onDeleted?.(`${row.orgID}|${row.csF2SubcategoryID}|${row.maturityLevel}|${row.attributeNum}`);
      success('Deleted');
    } catch {
      error('Failed to delete');
    }
  };

  const customList = existingRows.filter(r =>
    r.orgID === orgID &&
    r.csF2SubcategoryID === csf2SubcategoryID &&
    (r.isCustom || r.customAttributeDefinition || r.customAttributeNum != null)
  );

  return (
    <Paper variant="outlined" sx={{ mt: 2, p: 2 }}>
      <Stack direction="row" alignItems="center" justifyContent="space-between" sx={{ mb: 1 }}>
        <Typography variant="subtitle1" sx={{ fontWeight: 800 }}>
          Custom Attributes — {orgName || '—'}
        </Typography>
        <Typography variant="caption" color="text.secondary">{subcatName}</Typography>
      </Stack>

      {/* modern, compact input row */}
      <Stack direction={{ xs:'column', md:'row' }} spacing={1} alignItems={{ md: 'center' }}>
        <Select
          size="small"
          value={ml}
          onChange={(e) => setMl(Number(e.target.value))}
          sx={{ width: 140 }}
        >
          <MenuItem value={3}>Maturity 3</MenuItem>
          <MenuItem value={4}>Maturity 4</MenuItem>
        </Select>

        <TextField
          size="small"
          fullWidth
          placeholder="Attribute definition…"
          value={def}
          onChange={(e) => setDef(e.target.value)}
        />

        <Select
          size="small"
          value={att}
          onChange={(e) => setAtt(e.target.value)}
          displayEmpty
          sx={{ width: { xs:'100%', md: 220 } }}
          renderValue={(v) => v || '2025 Attestation — optional'}
        >
          <MenuItem value=""><em>—</em></MenuItem>
          {ATTEST_OPTIONS.map(o => <MenuItem key={o} value={o}>{o}</MenuItem>)}
        </Select>

        <Button disabled={!canAdd} onClick={handleAdd}>Add</Button>
      </Stack>

      <Divider sx={{ my: 2 }} />

      {customList.length ? (
        <Stack spacing={1}>
          {customList.map(r => (
            <Paper key={`${r.maturityLevel}-${r.customAttributeNum ?? r.attributeNum}`} variant="outlined" sx={{ p: 1, display:'flex', alignItems:'center', justifyContent:'space-between' }}>
              <Stack direction="row" spacing={1} alignItems="center" sx={{ minWidth: 0 }}>
                <Chip size="small" label={`ML ${r.maturityLevel}`} />
                <Typography variant="body2" sx={{ whiteSpace:'nowrap', overflow:'hidden', textOverflow:'ellipsis', maxWidth:'60vw' }}>
                  {r.customAttributeDefinition || r.attributeDefinition}
                </Typography>
                {r.customAttributeAttestation ? (
                  <Chip size="small" label={r.customAttributeAttestation} color={
                    r.customAttributeAttestation === 'Meet' ? 'success'
                    : r.customAttributeAttestation === 'Partial Meet' ? 'warning' : 'error'
                  } sx={{ ml: 1 }}/>
                ) : null}
              </Stack>

              <Stack direction="row" spacing={0.5}>
                <Tooltip title="Edit">
                  <IconButton size="small" onClick={() => startEdit(r)}><EditRoundedIcon fontSize="small" /></IconButton>
                </Tooltip>
                <Tooltip title="Delete">
                  <IconButton size="small" onClick={() => remove(r)}><DeleteRoundedIcon fontSize="small" /></IconButton>
                </Tooltip>
              </Stack>
            </Paper>
          ))}
        </Stack>
      ) : (
        <Typography variant="body2" color="text.secondary">No custom attributes yet.</Typography>
      )}

      {/* Edit dialog */}
      <Dialog open={editOpen} onClose={() => setEditOpen(false)} fullWidth maxWidth="sm">
        <DialogTitle>Edit custom attribute</DialogTitle>
        <DialogContent sx={{ pt: 1 }}>
          <Stack spacing={2}>
            <TextField
              label="Attribute definition"
              fullWidth
              value={editDef}
              onChange={(e) => setEditDef(e.target.value)}
            />
            <Select
              value={editAtt}
              onChange={(e) => setEditAtt(e.target.value)}
              displayEmpty
              renderValue={(v) => v || '2025 Attestation — optional'}
            >
              <MenuItem value=""><em>—</em></MenuItem>
              {ATTEST_OPTIONS.map(o => <MenuItem key={o} value={o}>{o}</MenuItem>)}
            </Select>
          </Stack>
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setEditOpen(false)} color="inherit">Cancel</Button>
          <Button onClick={saveEdit} disabled={!editDef.trim()}>Save</Button>
        </DialogActions>
      </Dialog>
    </Paper>
  );
}
